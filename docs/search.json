[
  {
    "objectID": "PART_1/04_inline.html",
    "href": "PART_1/04_inline.html",
    "title": "4  A Competição",
    "section": "",
    "text": "4.1 Documentação\nQualquer texto que precede um método será considerado um docstrings, ou documentação\nPara acessar o texto no REPL digite ?, e em seguida o nome da função.\n?qual_tipo\nPara textos mais longos, utiliza-se aspas triplas \"\"\" no começo e no final para delimitar literais de String que podem conter \" e ignorar a indentação inicial. Isso é particularmente útil quando você deseja definir uma String de várias linhas ou uma String que contém aspas.\ns = \"\"\"Isto é uma \"string\" que abrange\nvárias linhas e contém \"aspas\".\"\"\"\nExiste um padrão para escrita de docstrings disponivel na documentação",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>A Competição</span>"
    ]
  },
  {
    "objectID": "PART_1/00_intro_story.html",
    "href": "PART_1/00_intro_story.html",
    "title": "Parte 1",
    "section": "",
    "text": "Era uma vez, numa vasta savana adornada com capim alto e acácias dispersas, onde residia Daisy, uma suricata curiosa e destemida.\n\n\n\n\n\nEla se aventura no aprendizado da programação com o objetivo de se tornar uma hacker, transformando suas atividades diárias em programas intrigantes.\nAo longo deste texto, você encontrará breves relatos da vida de Daisy, entrelaçados com trechos de código que representam diversos aspectos da narrativa. Ambos se entrelaçam, e a compreensão do código ganha significado à luz das experiências de vida de Daisy.\n\n\n\n\n\n\nTodos os métodos apresentados na Parte 1 serão utilizadas de uma forma ou outra nos próximos capitulos.\n\n\n\nÉ altamente recomendável realizar todos os exercícios, mesmo que pareçam simples à primeira vista, pois eles têm o propósito de familiarizá-lo com a sintaxe de Julia.\nAdicionalmente, alguns trechos de código serão acompanhados pelos resultados exibidos abaixo do código-fonte, proporcionando a certeza de que seus resultados estão em conformidade com as expectativas. Por exemplo:\n\n@show \"Eu sou Daisy\"\npeso = 500 # em gramas\n@show peso/1000; # em kg\n\n\"Eu sou Daisy\" = \"Eu sou Daisy\"\npeso / 1000 = 0.5",
    "crumbs": [
      "Parte 1"
    ]
  },
  {
    "objectID": "PART_1/01_for_if.html",
    "href": "PART_1/01_for_if.html",
    "title": "1  Sair de Casa",
    "section": "",
    "text": "1.1 for\nDado uma coleção, por exemplo um Array, você pode acessar cada elemento da seguinte forma\nOutra alternativa é ter uma variável com o índice de cada elemento\nContudo, a maneira recomendada para produzir indices e valores ao mesmo tempo é com enumerate",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Sair de Casa</span>"
    ]
  },
  {
    "objectID": "PART_1/01_for_if.html#for",
    "href": "PART_1/01_for_if.html#for",
    "title": "1  Sair de Casa",
    "section": "",
    "text": "for\n\n\n\n\n\n\ncoleção = [\"a\", \"b\", \"1\", \"2\"]\nfor item in coleção\n    println(item)\nend\n\na\nb\n1\n2\n\n\n\n\n\n\n\n\n\n\n\nExercício 1.1\n\n\n\n\n\nPreencha os espaços em branco a seguir para que meses_do_ano armazene Strings com todos os meses do ano, e os exiba na tela.\n\nmeses_do_ano = ______________\nfor _____ in meses_do_ano\n    println(_____)\nend\n\n\n\n\n\n\n\n\n\n\nSolução 1.1\n\n\n\n\n\n\nmeses_do_ano = [\"Janeiro\", \"Fevereiro\", \"Março\", \"Abril\", \n\"Maio\", \"Junho\", \"Julho\", \"Agosto\", \"Setembro\", \n\"Outubro\", \"Novembro\", \"Dezembro\"]\nfor mês in meses_do_ano\n    println(mês)\nend\n\n\n\n\n\n\n\n\n\n\n\neachindex\n\n\n\n\n\n\ncoleção = [\"a\", \"b\", \"1\", \"2\"]\nfor idx in eachindex(coleção)\n    valor = coleção[idx]\n    println(\"indice $(idx) tem valor $(valor)\")\nend\n\nindice 1 tem valor a\nindice 2 tem valor b\nindice 3 tem valor 1\nindice 4 tem valor 2\n\n\n\n\n\n\n\n\n\n\n\nExercício 1.2\n\n\n\n\n\nPreencha os espaços em branco no código fornecido para obter a saída desejada.\n\ncoleção = [\"a\", \"b\", \"1\", \"2\"]\nfor idx in eachindex(coleção)\n    valor = coleção[idx]\n    println(\"______ $(______) tem valor $(______)\")\nend\n\nSaída Desejada:\n\níndice 1 tem valor a\níndice 2 tem valor b\níndice 3 tem valor 1\níndice 4 tem valor 2\n\n\n\n\n\n\n\n\n\n\nSolução 1.2\n\n\n\n\n\n\ncoleção = [\"a\", \"b\", \"1\", \"2\"]\nfor idx in eachindex(coleção)\n    valor = coleção[idx]\n    println(\"indice $(idx) tem valor $(valor)\")\nend\n\n\n\n\n\n\n\n\n\n\n\nenumerate\n\n\n\n\n\n\ncoleção = [\"a\", \"b\", \"1\", \"2\"]\nfor (idx, valor) in enumerate(coleção)\n    println(\"indice $(idx) tem valor $(valor)\")\nend",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Sair de Casa</span>"
    ]
  },
  {
    "objectID": "PART_1/01_for_if.html#if",
    "href": "PART_1/01_for_if.html#if",
    "title": "1  Sair de Casa",
    "section": "1.2 if",
    "text": "1.2 if\nCondicionais em Julia usam o comando if\n\n\n\n\n\n\nìf\n\n\n\n\n\n\ncondição_1 = true\ncondição_2 = true\nif condição_1 == true\n    println(\"entrou condição 1\")\nelseif condição_2 == true\n    println(\"entrou condição 2\")\nelse\n    println(\"entrou no else\")\nend\n\nentrou condição 1\n\n\n\n\n\nSe a condição_1 já é uma variável booleana (true/false), a comparação pode ser omitidida\n\n\n\n\n\n\nìf simplificado\n\n\n\n\n\n\ncondição_1 = false\ncondição_2 = true\nif condição_1\n    println(\"entrou condição 1\")\nelseif condição_2\n    println(\"entrou condição 2\")\nelse\n    println(\"entrou no else\")\nend\n\nentrou condição 2\n\n\n\n\n\n\n\n\n\n\n\nExercício 1.3\n\n\n\n\n\nSimplifique o código de Daisy sem a comparação explicita da variável permissão\n\nfor dia in dias_da_semana\n    if ______________\n        println(\"Daisy PODE CAÇAR na $(dia)\")\n    else\n        println(\"Daisy FICA EM CASA na $(dia)\")\n    end\nend\n\n\n\n\n\n\n\n\n\n\nSolução 1.3\n\n\n\n\n\n\nfor dia in dias_da_semana\n    if rand() &gt; 0.5\n        println(\"Daisy PODE CAÇAR na $(dia)\")\n    else\n        println(\"Daisy FICA EM CASA na $(dia)\")\n    end\nend",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Sair de Casa</span>"
    ]
  },
  {
    "objectID": "PART_1/02_function.html",
    "href": "PART_1/02_function.html",
    "title": "2  Popularidade",
    "section": "",
    "text": "2.1 Functions\nExistem 3 maneiras de criar funções em Julia.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Popularidade</span>"
    ]
  },
  {
    "objectID": "PART_1/02_function.html#functions",
    "href": "PART_1/02_function.html#functions",
    "title": "2  Popularidade",
    "section": "",
    "text": "Declaração Padrão\n\n\n\n\n\n\nfunction achar_domingos(dias)\n    idx_domingos = Int[]\n    for (idx, dia) in enumerate(dias) \n        if dia == \"Dom\"\n            push!(idx_domingos, idx)\n        end\n    end\n    return idx_domingos\nend\n\n\n\n\n\n\n\n\n\n\nExercício 2.1\n\n\n\n\n\nComplete a função a seguir para que ela retorne a permissão de caça com base em uma probabilidade fornecida como variável.\n\nfunction pode_caçar(probabilidade)\n    if probabilidade &lt; ____ || probabilidade &gt; ______\n        @error \"Probabiidade Inválida\"\n    end\n\n    permissão = ________ &gt; ________\n    if __________\n        return ________\n    end\n    return ________\nend\n\n\n\n\n\n\n\n\n\n\nSolução 2.1\n\n\n\n\n\n\nfunction pode_caçar(probabilidade)\n    if probabilidade &lt; 0 || probabilidade &gt; 1\n        @error \"Probabiidade Inválida\"\n    end\n\n    permissão = rand() &gt; probabilidade\n    if permissão\n        return true\n    end\n    return false\nend\npode_caçar(probabilidade)\n\n\n\n\n\n\n\n\n\n\nDeclaração em Uma Linha\n\n\n\n\n\nA segunda maneira é apenas o nome da função.\nEsta forma é conveniente para funções simples que têm uma única expressão como corpo. O exemplo a seguir é equivalente ao exemplo anterior, porém mais compacto.\n\nachar_domingos(dado) = [idx for (idx, dia) in enumerate(dias) if dia == \"Dom\"];\n\n\n\n\n\n\n\n\n\n\nExercício 2.2\n\n\n\n\n\nCrie uma função, de uma linha, que retorne um array com os dias da semana.\n\n\n\n\n\n\n\n\n\nSolução 2.2\n\n\n\n\n\n\ndias_semana() = [\"Seg\", \"Ter\", \"Qua\", \"Qui\", \"Sex\", \"Sab\", \"Dom\"]\n\n\n\n\n\n\n\n\n\n\nFunção Anônima\n\n\n\n\n\nTerceira maneira é com funções anônimas, isto é, sem nomes, que são indicadas com -&gt;.\nSão úteis quando você precisa passar uma função como argumento para outra função ou quando deseja criar funções temporárias. Esse cenário acontece quando precisamos passar funções como entradas, aqui mostramos a função map - que será explicada na próxima atividade.\n\ndias = [\"Sab\", \"Dom\", \"Seg\"]\nmap(x -&gt; x==\"Dom\", dias)\n\nÉ equivalente a criar uma função temporária\n\ndias = [\"Sab\", \"Dom\", \"Seg\"]\nfunction _temp(x)\n    if x==\"Dom\"\n        return true\n    else\n        return false\n    end\nend\nmap(_temp, dias)",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Popularidade</span>"
    ]
  },
  {
    "objectID": "PART_1/02_function.html#operação-elemento-a-elemento",
    "href": "PART_1/02_function.html#operação-elemento-a-elemento",
    "title": "2  Popularidade",
    "section": "2.2 Operação Elemento-a-Elemento",
    "text": "2.2 Operação Elemento-a-Elemento\nO ponto . antes de qualquer operador significa que o respectivo método será aplicado em todos os elementos do vetor. Esse ponto é a função broadcast.\n\n\n\n\n\n\nbroadcast\n\n\n\n\n\nComparações podem ser feitas com o comando == ou isequal\n\nA = [\"a\", \"b\", \"a\", \"c\"]\n@show A .== \"a\";\n@show isequal.(A, \"a\");\n\nA .== \"a\" = Bool[1, 0, 1, 0]\nisequal.(A, \"a\") = Bool[1, 0, 1, 0]\n\n\nEquivalente ao comando\n\n[elemento == \"a\" for elemento in A]\n\n\n\n\n\n\n\n\n\n\nExercício 2.3\n\n\n\n\n\nCrie uma função minha_comparação que retorna true/false de tal forma que ela obtenha a saída desejada\n\n@show minha_comparação(\"Seg\", \"SEG\") # false\n@show minha_comparação.(\"Seg\", [\"SEG\", \"Seg\"]) # Bool[0,1]\n\n\n\n\n\n\n\n\n\n\nSolução 2.3\n\n\n\n\n\n\nfunction minha_comparação(a,b)\n    if a==b\n        return true\n    else\n        return false\n    end\nend\n\nminha_comparação (generic function with 1 method)\n\n\n\n\n\n\n\n\n\n\n\nExercício 2.4\n\n\n\n\n\nEscreva uma versão simplificada da função calendario_semanal de forma que elimite as variáveis qtd, agenda, permissão e dias_caçada.\n\n\n\n\n\n\n\n\n\nSolução 2.4\n\n\n\n\n\n\nfunction calendario_semanal_simplificado(dias)    \n    nomes_dias_caçada = String[]\n    for i in eachindex(dias)\n        # probabilidade maior que 50%\n        if rand() &gt; 0.5\n            push!(nomes_dias_caçada, dias[i])\n        end\n    end\n    return nomes_dias_caçada\nend\ndias_da_semana = [\"Seg\", \"Ter\", \"Qua\", \n                  \"Qui\", \"Sex\", \"Sab\", \n                  \"Dom\"]\nRandom.seed!(222)\nprintln( \"Dias que podem sair para caçar: \" )\nprintln( calendario_semanal_simplificado(dias_da_semana) )\n\nDias que podem sair para caçar: \n[\"Ter\", \"Qua\", \"Sex\"]",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Popularidade</span>"
    ]
  },
  {
    "objectID": "PART_1/03_map.html",
    "href": "PART_1/03_map.html",
    "title": "3  O Convite",
    "section": "",
    "text": "3.1 Explicando a mensagem\nVamos falar em detalhes sobre a função map que foi utilizada na atividade passada, porém sem muitos detalhes.\nOutra maneira de escrever o mesmo código é utilizando Função Anônima\nmap( x-&gt;replace(x, \"A\" =&gt; \"B\"), coleção)\nNesse exemplo, a função temporária possui apenas 1 comando (replace). E se o código possui várias linhas? Nesse cenário a leitura ficaria mais confusa, e existe outra sintaxe mais conveniente, o do",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>O Convite</span>"
    ]
  },
  {
    "objectID": "PART_1/03_map.html#explicando-a-mensagem",
    "href": "PART_1/03_map.html#explicando-a-mensagem",
    "title": "3  O Convite",
    "section": "",
    "text": "map\n\n\n\n\n\nA função map espera aplicar uma função foo a cada elemento em uma coleção.\n\nfoo(x) = replace(x, \"A\" =&gt; \"B\")\nrespostas = map(foo, coleção)\n\nO retorno dessa função também é uma coleção. O código equivalente a esse exemplo seria\n\nfoo(x) = replace(x, \"A\" =&gt; \"B\")\nrespostas = []\nfor item in coleção\n    push!(respostas, foo(item))\nend\n\n\n\n\n\n\n\n\n\n\n\n\nExercício 3.1\n\n\n\n\n\nO código a seguir obtêm os dias da semana que Daisy pode sair pra caçar com uma função anônima dentro da função filter.\nEscreva um novo código, com for e if, afim de realizar a mesma operação que o filter\n\nfilter(x-&gt;!isequal(x, \"Em Casa\"), [\"Em Casa\", \"Em Casa\", \"Ter\"])\n\n1-element Vector{String}:\n \"Ter\"\n\n\n\n\n\n\n\n\n\n\n\nSolução 3.1\n\n\n\n\n\n\ndias_caçada = String[]\nfor dia in [\"Em Casa\", \"Em Casa\", \"Ter\"]\n    if !isequal(dia, \"Em Casa\") # if dia ≠ \"Em Casa\"\n        push!(dias_caçada, dia)\n    end\nend\n\n\n\n\n\n\n\n\n\n\n\ndo\n\n\n\n\n\nQualquer função cujo primeiro argumento é uma função (como é o caso da função map) pode ser reescrita como a sintaxe do, isto é, a função do argumento se torna uma função anônima em um bloco.\n\nmap(coleção) do x\n    replace(x, \"A\" =&gt; \"B\")\nend\n\nEm códigos com apenas um comando, essa sintaxe não é necessária, contudo, para funções com mais instruções, essa sintaxe se torna muito conveniente.\n\ncoleção = [\"A\", \"a\", \"B\", \"b\"]\nmap(coleção) do x\n    y = replace(x, \"A\" =&gt; \"B\")\n    z = replace(y, \"a\" =&gt; \"b\")\n    z\nend\n\n4-element Vector{String}:\n \"B\"\n \"b\"\n \"B\"\n \"b\"\n\n\nA versão alternativa com a sintaxe -&gt; requer a adição de begin e end\n\nmap( x-&gt; begin \n    y = replace(x, \"A\" =&gt; \"B\"); \n    z = replace(y, \"a\" =&gt; \"b\"); \n    z end, coleção)\n\n\n\n\n\n\n\n\n\n\nExercício 3.2\n\n\n\n\n\nEscreva um código, com o comando map, que permita Daisy caçar todas as Qua e Qui, mas nos outros dias, a suricata ficará em casa.\n\n\n\n\n\n\n\n\n\nSolução 3.2\n\n\n\n\n\n\ndias = [\"Seg\", \"Ter\", \"Qua\", \n        \"Qui\", \"Sex\", \"Sab\", \n        \"Dom\"]\ndias_caçada = map(dias) do dia\n    if dia in [\"Qua\", \"Qui\"]\n        \"pode caçar\"\n    else\n        \"fica em casa\"\n    end\nend\n\n\n\n\n\n\n\n\n\n\nPortanto, o código de Daisy esta dizendo implicitamente, que ele foi construído com uma Função Anônima, em homenagem ao grupo hacker Anonymous.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>O Convite</span>"
    ]
  },
  {
    "objectID": "PART_1/03_map.html#usando-o-map",
    "href": "PART_1/03_map.html#usando-o-map",
    "title": "3  O Convite",
    "section": "3.2 Usando o map",
    "text": "3.2 Usando o map\nDaisy decidiu usar a função map em seus códigos de agora em diante. A nova implementação da função calendario_semanal ficou\n\nfunction calendario_semanal(dias)\n\n    agenda = map(dias) do dia\n        if rand() &gt; 0.5\n            \"sim\"\n        else\n            \"não\"\n        end\n    end\n\n    dias_caçada = findall( agenda .== \"sim\" )\n    nomes_dias_caçada = dias_da_semana[dias_caçada]\n    return nomes_dias_caçada\nend\n\n\n\n\n\n\n\nExercício 3.3\n\n\n\n\n\nAltere a função anônima dentro do map, de tal forma que você possa substituir o comando findall pelo comando filter.\n\n\n\n\n\n\n\n\n\nSolução 3.3\n\n\n\n\n\n\nfunction calendario_semanal(dias)\n    agenda = map(dias) do dia\n        if rand() &gt; 0.5\n            dia\n        else\n            \"não\"\n        end\n    end\n\n    nomes_dias_caçada = filter(x-&gt;!isequal(x, \"não\"), agenda)\n    return nomes_dias_caçada\nend",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>O Convite</span>"
    ]
  },
  {
    "objectID": "PART_1/05_named_tuples.html",
    "href": "PART_1/05_named_tuples.html",
    "title": "5  Tuplas Nomeadas",
    "section": "",
    "text": "Daisy já sabe quais dias terá suas aventuras, para guardar seus momentos mágicos, ela quer guardar os insetos que ela caçará. Um banco de dados é muito complexo nesse momento, ela prefere Tuplas Nomeadas, porque seus códigos ficam mais fácil de interpretar.\n\n\n\n\n\n\nSintaxe: Named Tuple\n\n\n\n\n\nTupla Nomeada são variáveis que são armazenadas juntas, e você não poderá alterar seus valores depois.\n\na = 1\nb = 2\nc = (variavel_a = a, variavel_b = b)\n@show c.variavel_a, c.variavel_b\n\n# ou apenas 1 elemento usa a virgula\nc = (variavel_a = a, );\n\n(c.variavel_a, c.variavel_b) = (1, 2)\n\n\n\n\n\nA caçada é variada, o Menu consiste de 4 insetos, besouros, aranhas, escorpiões, gafanhotos, e a cada caçada, Daisy tem a mesma chance de obter um inseto.\n\n\n\n\n\n\nSintaxe: rand\n\n\n\n\n\nPor padrão a função rand() gera valores aleatórios entre 0 e 1, mas você pode dar um vetor, e a função irá gerar valores aleatórios baseados no conteúdo do vetor.\n\nx = [\"aranha\", \"besouro\", \"escorpião\"]\n@show x\n@show rand(x);\n\nx = [\"aranha\", \"besouro\", \"escorpião\"]\nrand(x) = \"aranha\"\n\n\n\n\n\nDaisy vai armazenar o resultado de cada caçada de forma independente (nada de matrizes), ela usará um vetor de vetores.\n\n\n\n\n\n\nSintaxe: [] e push!\n\n\n\n\n\nVocê pode criar uma variável vazia e armazenar o que desejar com o comando push!, repare que existe um ! no nome, ou seja, ela altera a variável de entrada.\n\nx = []\n@show x\npush!(x, \"uma lesma\")\n@show x\npush!(x, \"outra lesma\")\n@show x;\n\nx = Any[]\nx = Any[\"uma lesma\"]\nx = Any[\"uma lesma\", \"outra lesma\"]\n\n\n\n\n\nJuntando todos os conhecimentos, Daisy além de criar a função que armazena o histórico de caçadas, ainda exibe de forma estruturada qual animal foi caçado, e em qual dia.\n\nfunction historico_caçadas(calendario_mensal, menu)\n    dias_da_semana = [\"Segunda\",\"Terça\", \"Quarta\",\n                \"Quinta\", \"Sexta\",\n                \"Sábado\", \"Domingo\"]\n\n    qtd_semanas, qtd_dias = size(calendario_mensal)\n    sim = one(eltype(calendario_mensal))\n\n    caçada_por_semana = map(1:qtd_semanas) do indice_semana\n        caçada_semanal = [] # vetor vazio\n\n        for indice_dia in 1:qtd_dias\n            if calendario_mensal[indice_semana, indice_dia] == sim\n                o_q_foi_caçado = rand(menu)\n                historico = ( dia = dias_da_semana[indice_dia],\n                              inseto = o_q_foi_caçado )\n                push!(caçada_semanal, historico)\n            end\n        end\n        caçada_semanal\n    end\n\n    return caçada_por_semana\nend\nmenu = [\"Besouro\", \"Aranha\", \"Escorpião\", \"Gafanhoto\"]\nagenda_fev = rand(Bool, 4, 7) # maneira compacta de obter 0 e 1\ncaçadas_fev = historico_caçadas(agenda_fev, menu)\n\nfor indice_semana = 1:4\n    println(\"Na semana $(indice_semana) Daisy pegou\")\n    for historico in caçadas_fev[indice_semana]\n        println(\"  - $(historico.dia) no $(historico.inseto)\")\n    end\nend\n\nNa semana 1 Daisy pegou\n  - Terça no Besouro\n  - Sexta no Escorpião\n  - Sábado no Besouro\nNa semana 2 Daisy pegou\n  - Quarta no Gafanhoto\n  - Domingo no Escorpião\nNa semana 3 Daisy pegou\n  - Terça no Aranha\n  - Quarta no Aranha\n  - Sábado no Aranha\nNa semana 4 Daisy pegou\n  - Quarta no Gafanhoto\n  - Domingo no Besouro",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Tuplas Nomeadas</span>"
    ]
  },
  {
    "objectID": "PART_2/00_going_travelling.html",
    "href": "PART_2/00_going_travelling.html",
    "title": "Parte 2",
    "section": "",
    "text": "Mapas\nDaisy é um viajante ávido e adora explorar novos lugares. Ela também é apaixonada por cartografia e cria mapas de suas viagens para documentar suas jornadas.\nNo entanto, ela geralmente acha difícil retratar com precisão o terreno e as características geográficas em seus mapas. Para melhorar a qualidade de seus mapas, ela pesquisou várias técnicas e recentemente se interessou por algoritmos de detecção de bordas.\nUsando detecção de bordas, ela espera ser capaz de identificar e destacar com mais precisão os limites de diferentes características do terreno, como montanhas, rios e vales, e tornar seus mapas mais informativos e visualmente atraentes.",
    "crumbs": [
      "Parte 2"
    ]
  },
  {
    "objectID": "PART_2/00_going_travelling.html#paralelismo",
    "href": "PART_2/00_going_travelling.html#paralelismo",
    "title": "Parte 2",
    "section": "Paralelismo",
    "text": "Paralelismo\nBem-vindo a este capítulo emocionante! Aqui você terá a oportunidade de realizar uma operação incrível - Identificar Bordas em Imagens - e ainda utilizar o poder do paralelismo com diferentes ferramentas. Não se preocupe se ainda não tem uma imagem em mente, você pode escolher a que mais lhe agrada e usá-la como exemplo. Vamos lá!",
    "crumbs": [
      "Parte 2"
    ]
  },
  {
    "objectID": "PART_2/06_edge_detection.html",
    "href": "PART_2/06_edge_detection.html",
    "title": "6  Detecção de Bordas",
    "section": "",
    "text": "O objetivo de Daisy é aprimorar seus mapas detectando bordas, e seu algoritmo é muito simples, ela busca por mudanças abruptas na intensidade. Ela fez o desenho abaixo para ilustrar sua ideia, primeiro, ela converte a imagem do mapa em escala de cinza, compara pixels adjacentes, e diz que qualquer pixel acima de um valor limite (threshold) será considerado uma borda.\n\n\n\n\n\nDepois de detectar as bordas, Daisy pinta a imagem original com pontos vermelho para destacá-los. Dessa vez Daisy precisou instalar pacotes em Julia, ela precisou usar o Images.jl para carregar uma image de alta resolução do planeta todo.\n\n\n\n\n\n\nInstalar Pacotes\n\n\n\n\n\nA primeira maneira de instalar pacotes é com o pacote Pkg\n\nimport Pkg\nPkg.add(\"Images\")\n\nO segundo método é pelo terminal (também chamado REPL de Julia). Você deve apertar o ] no teclado. Isso vai alterar a palavra chave julia&gt; para algo do tipo (@v1.9) pkg&gt;. Em seguida, você pode dizer o comando de instalação.\n\n(@v1.9) pkg&gt; add Images\n\nSerá esperado que você instale todos os pacotes futuramente apresentados.\n\n\n\n\n\n\n\n\n\nSintaxe: Canais de Cores\n\n\n\n\n\nPor padrão, o pacote Images.jl vai carregar imagens representadas em RGB(red, green, blue).\nExistem funções (felizmente) com os mesmos nomes que permitem encontrar os respectivos valores para cada pixel.\n\nsua_imagem = load(\".....\")\num_pixel = sua_imagem[3,5]\nr,g,b = red(um_pixel), green(um_pixel), blue(um_pixel)\n\nMas por exemplo, para encontrar todos os vermelhos de uma imagem, você deve usar o operador broadcast .\n\nsua_imagem = load(\".....\")\ncanal_vermelho = red.(sua_imagem)\n\n\n\n\n\nusing Images\nvermelho = RGBA(1.0,0,0.,1)\nthreshold = 0.02\n\nfunction detectar_bordas(imagem, threshold)\n    T = eltype(imagem) # tipo da matriz\n    altura, comprimento = size(imagem)\n    imagem_nova = zeros(T, altura, comprimento)\n\n    for y = 2:comprimento\n        for x = 2:altura\n            atual = imagem[x,y]\n            acima = imagem[x-1,y]\n            esquerda  = imagem[x,y-1]\n\n            if abs(atual-esquerda) ≥ threshold &&\n               abs(atual-acima) ≥ threshold\n                # se é uma borda, anota com '1'\n                imagem_nova[x,y] = one(T)\n            end\n        end\n    end\n    return imagem_nova\nend\n\nfunction pintar_bordas(imagem, mapa_de_bordas, vermelho)\n    imagem_com_bordas = deepcopy(imagem)\n\n    um = one(eltype(mapa_de_bordas))\n    onde_pintar = findall(mapa_de_bordas .== um)\n    imagem_com_bordas[onde_pintar] .= vermelho\n\n    return imagem_com_bordas\nend\n_original = Images.load(pwd()*\"/world.png\");\nimagem = (red.(_original) + green.(_original) + blue.(_original))/3\n\nbordas = detectar_bordas(imagem, threshold)\nimagem_com_bordas = pintar_bordas(_original, bordas, vermelho)\n\nimagem_com_bordas\n\nEsse código foi escrito com loops sem explorar nenhum paralelismo, por isso iremos chamar esse código de versão sequencial nas próximas seções.",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Detecção de Bordas</span>"
    ]
  },
  {
    "objectID": "PART_2/07_at_threads.html",
    "href": "PART_2/07_at_threads.html",
    "title": "7  Threads.@threads",
    "section": "",
    "text": "Daisy quer tornar seu algoritmo de detecção de borda mais eficiente usando processamento paralelo com Threads. Sua opção mais simples em Julia é uma macro usada para a execução paralela threads.@Threads. Quando essa macro é usada, as iterações de loop são distribuídas igualmente entre as várias Threads disponíveis.\n\n\n\n\n\n\nNúmero de Threads\n\n\n\n\n\nO número de Threads usados para a execução paralela é determinado pela variável de ambiente JULIA_NUM_THREADS. Você pode verificar quantos threads você tem disponível chamando a função threads.nthreads()\n\nprintln(Threads.nthreads())\n\n\n\n\nPara deixar o código mais limpo, Daisy transformou a operação de detecção de bordas em uma função independente, assim ela pode focar apenas nos loops.\n\n\n\n\n\n\nkernel\n\n\n\nÉ tradição chamar a lógica central do algoritmo como kernel.\n\n\n\n\n\n\n\n\nSintaxe: @inline\n\n\n\n\n\nFazer uma chamada de função pode ser levemente mais demorado do que um programa contendo todos os comandos.\nSe você quer escrever em formato modular, com várias funções, mas o código final produzido pelo compialdor se torne um código extenso, com todas as funções encapsuladas em apenas um código, você pode dizer isso ao compilador com a macro @inline.\n\n\n\n\nfunction bordas_at_threads(imagem, threshold)\n    T = eltype(imagem) # tipo da matriz\n    altura, comprimento = size(imagem)\n    imagem_nova = zeros(T, altura, comprimento)\n\n    Threads.@threads for y = 2:comprimento\n        for x = 2:altura\n            kernel_bordas!(imagem, imagem_nova, T, threshold, x, y)\n        end\n    end\n    return imagem_nova\nend\n\n@inline function kernel_bordas!(imagem, imagem_nova, tipo_matrix, threshold, x, y)\n    atual = imagem[x,y]\n    acima    = imagem[x-1,y]\n    esquerda  = imagem[x,y-1]\n\n    if abs(atual-esquerda) ≥ threshold &&\n        abs(atual-acima) ≥ threshold\n        # se é uma borda, anota com '1'\n        imagem_nova[x,y] = one(tipo_matrix)\n    end\n    return nothing\nend\n\nbordas_paralelo_v1 = bordas_at_threads(imagem, threshold)\n# testar que código sequencial e paralelo produze o mesmo resultado\n@assert all(bordas .≈ bordas_paralelo_v1)\n\nA função all() é usada para verificar se todos os elementos nas duas imagens são (aproximadamente) iguais usando o operador ≈ (\\approx + TAB). Se o teste passar, significa que a implementação paralela produz a mesma saída que a implementação serial.",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`Threads.@threads`</span>"
    ]
  },
  {
    "objectID": "PART_2/08_at_spawn.html",
    "href": "PART_2/08_at_spawn.html",
    "title": "8  Threads.@spawn",
    "section": "",
    "text": "Daisy está animada pois percebeu que existem loops encadeados (um for dentro de outro for) que potencialmente podem se beneficiar de mais paralelismo. Depois de algumas pesquisas, ela decidiu usar Threads.@spawn em seu código. Essa macro permite que cada iteração dos loops sejam executados de forma assíncrona.\nQuando @spawn é usado, uma novo Thread é criada enquanto o thread principal continua com sua execução sem esperar que as Threads terminem. Para fazer o programa principal aguardar pelas Thredas, Daisy precisou usar a macro @sync, para sincronizar as Threads.\nA mudança que Daisy precisou fazer em seu código foi pequena, trocando Threads.@threads por Threads.@spawn e @sync.\n\nfunction bordas_at_spawn(imagem, threshold)\n    T = eltype(imagem) # tipo da matriz\n    altura, comprimento = size(imagem)\n    imagem_nova = zeros(T, altura, comprimento)\n\n    @sync Threads.@spawn for y = 2:comprimento\n        for x = 2:altura\n            kernel_bordas!(imagem, imagem_nova, T, threshold, x, y)\n        end\n    end\n    return imagem_nova\nend\n\nbordas_paralelo_v2 = bordas_at_spawn(imagem, threshold)\n@assert all(bordas .≈ bordas_paralelo_v2)\n\nDaisy reparou que seu novo código é mais lento. Na próxima seção você descobrirá o motivo.\n\n\n\n\n\n\nPode conferir o tempo de execução com\n\n@time bordas_at_threads(imagem, threshold);\n@time bordas_at_spawn(imagem, threshold);",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>`Threads.@spawn`</span>"
    ]
  },
  {
    "objectID": "PART_2/09_spatial_divison.html",
    "href": "PART_2/09_spatial_divison.html",
    "title": "9  Divisão Espacial",
    "section": "",
    "text": "Daisy descobriu que o motivo para seu código com Threads.@spawn estar lento é que ela criou muitas Threads, ou seja, paras criar várias Threads demora algum tempo e o sistema operacional precisa anotar na memória que essa Threads existem. A solução anterior, com Threads.@threads foi mais eficiente, pois ela criou menos Threads, e cada Thread tinha uma carga de trabalho maior.\nDaisy decidiu que precisa de um controle ainda maior de seu código, ela quer ser mais específica e definir exatamente as regiões no qual cada Thread será executada. Ela quer uma divisão como representado abaixo, utilizando uma foto de suas viagens. Cada cor representa uma região da imagem controlada por uma Thread diferente, nesse exemplo, com 4 Threads.\n\n\n\n\n\nSeu primeiro passo é criar uma nova função que tenha mais controle dos loops, permitindo que Daisy diga exatamente qual região será trabalhada. Isso significa criar um outro for para gerenciar as regiões. Para ser simples, ela criou apenas duas regiões, e ao testar o tempo de execução, viu que é melhor que o código com Threads.@spawn.\n\nfunction bordas_duas_regiões(imagem_cinza, threshold)\n    T = eltype(imagem_cinza)\n    altura, comprimento = size(imagem_cinza)\n    nova_imagem = zeros(T, altura, comprimento)\n    duas_regiões = [2:(comprimento÷2),\n                    (comprimento÷2+1):comprimento]\n\n    @sync for região_y in duas_regiões\n        Threads.@spawn for y = região_y\n            for x = 2:altura\n                kernel_bordas!(imagem_cinza, nova_imagem, T, threshold, x, y)\n            end\n        end\n    end\n\n   return nova_imagem\nend\n_teste_ = bordas_duas_regiões(imagem, threshold)\n@assert all(bordas .≈ _teste_)\n\n\n\n\n\n\n\nRepare que Threads.@spawn e @sync precisaram ser colocados em posições diferentes.\n\n\n\nDaisy sabia que seu computador possuia uma CPU com 4 Cores e 8 Threads, mas ela não queria escrever um código para dividir 8 regiões. Após uma busca rápida na internet, Daisy achou a função Iterators.partition que resolve seu problema.\nPor último, Daisy descobre o tamaho de cada partição baseado na quantidade Threads disponiveis, e em seguida descobre os indices de inicio e fim de cada região.\n\nfunction bordas_varias_regiões(imagem, threshold)\n    T = eltype(imagem)\n    altura, comprimento = size(imagem)\n    imagem_nova = zeros(T, altura, comprimento)\n\n    tamanho_região = comprimento ÷ Threads.nthreads()\n    varias_regiões = collect(\n        Base.Iterators.partition(2:comprimento, tamanho_região)\n        )\n\n    @sync for região_y in varias_regiões\n        Threads.@spawn for y = região_y\n            for x = 2:altura\n                kernel_bordas!(imagem, imagem_nova, T, threshold, x, y)\n            end\n        end\n    end\n\n   return imagem_nova\nend\n\nbordas_paralelo_v3 = bordas_varias_regiões(imagem, threshold)\n@assert all(bordas .≈ bordas_paralelo_v3)",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Divisão Espacial</span>"
    ]
  },
  {
    "objectID": "PART_2/10_threadsx.html",
    "href": "PART_2/10_threadsx.html",
    "title": "10  ThreadsX",
    "section": "",
    "text": "Daisy está ciente de que escrever código paralelo pode ser complicado e deseja garantir que sua implementação esteja correta. Para evitar bugs em potencial, ela buscou por pacote que possam a ajudar e acabou encontrando o pacote ThreadsX.jl, pois ele é muito fácil de usar, basta substituir funções Base, por exemplo, map por Threads.map.\nContudo, a função map executa uma função e retorna várias respostas. Da maneira como Daisy escreveu seu código, não existe nada a ser retornado, afinal, todas as mudanças já estão sendo escritas na matrix nova_imagem. Daisy então optou por usar a função ThreadsX.foreach, que existe justamente para esses cenários.\n\n\n\n\n\n\nSintaxe: foreach\n\n\n\n\n\nSe você gosta da sintaxe do map mas não precisa unir os resultados no final, use a função foreach.\n\nx = [1,2,3]\ny = map(x) do i\n    2*i\nend\n@show y;\n\nz = similar(x)\nforeach(x) do i\n    z[i] = 2*i\nend\n@show z;\n\ny = [2, 4, 6]\nz = [2, 4, 6]\n\n\n\n\n\n\nusing ThreadsX\nfunction bordas_ThreadsX(imagem, threshold)\n      T = eltype(imagem)\n    altura, comprimento = size(imagem)\n    imagem_nova = zeros(T, altura, comprimento)\n\n    tamanho_região = comprimento ÷ Threads.nthreads()\n    varias_regiões = collect( Base.Iterators.partition(2:comprimento, tamanho_região) )\n    ThreadsX.foreach(varias_regiões) do região_y\n        for y = região_y\n            for x = 2:altura\n                kernel_bordas!(imagem, imagem_nova, T, threshold, x, y)\n            end\n        end\n    end\n\n   return imagem_nova\nend\n\nbordas_paralelo_v4 = bordas_ThreadsX(imagem, threshold)\n@assert all(bordas .≈ bordas_paralelo_v4)",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>`ThreadsX`</span>"
    ]
  },
  {
    "objectID": "PART_2/11_parallel_stencil.html",
    "href": "PART_2/11_parallel_stencil.html",
    "title": "11  ParallelStencil",
    "section": "",
    "text": "Daisy teve um desenvolvimento tão incrível, que o lendário hacker, seu mestre Martin, decidiu levar Daisy a outro nível, Martin disse que processamento de imagens tem um grande aliado, Placas de Vídeo, e que Daisy deveria testar Cuda.\nNo entanto, os pais de Daisy não tem tanto dinheiro e se recusaram a comprar uma GPU. Os pais de Daisy acham que ela deveria estar caçando escorpiões, e quando ela ter seu próprio trabalho, ela mesmo poderá comprar sua RTX 4090.\nDaisy não desistiu. Ela procurou em toda parte por soluções, e finalmente se deparou com um pacote mágico chamado ParallelStencil.jl. Este pacote permitiu que ela fizesse seu código funcionar perfeitamente tanto em CPUs, quando em GPU, se disponível no computador.\nDaisy precisou ler a documentação do pacote, e descobriu que precisava modificar seu kernel para que funcionasse em paralelo, pois programação em placas de vídeo não tem loops com for ou while. O mesmo código (mesmo kernel) é executado em todas as regiões da image, e Daisy, a programadora, é responsável por descobrir qual o índice do loop imaginário.\n\n\n\n\n\n\nSe os parâmetros de entrada da função que está sendo executada em paralelo não forem complexos, o ParallelStencil.jl é capaz de identificar o tamanho da imagem e dividir as tarefas automaticamente. Por isso, foi necessário modificar a função novo_kernel para reduzir a quantidade de parâmetros de entrada necessários.\n\n\n\n\nusing ParallelStencil\n\n# Preciso iniciarlizar o pacote com o tipo de variavel padrão\n# que será utilizado, por exemplo, no comando\n# `ParallelStencil.@ones` a seguir\n@init_parallel_stencil(Threads, Float32, 2);\n\n# Se você já tem placa Nvidia configurada, pode usar essa linha\n# @init_parallel_stencil(CUDA, Float32, 2);\n\n@parallel_indices (x,y) function _novo_kernel!(imagem, imagem_nova, threshold)\n    T = eltype(imagem)\n    altura, comprimento = size(imagem)\n\n    if (    x &gt;= 2  && x &lt;= altura &&\n            y &gt;= 2  && y &lt;= comprimento )\n\n        atual = imagem[x,y]\n        acima    = imagem[x-1,y]\n        esquerda  = imagem[x,y-1]\n\n        if abs(atual-esquerda) ≥ threshold &&\n            abs(atual-acima) ≥ threshold\n            imagem_nova[x,y] = one(T)\n        end\n    end\n    return nothing\nend\n\nfunction bordas_ParStencil!(imagem, threshold)\n    imagem_nova = @zeros(size(imagem)...)\n    @parallel _novo_kernel!(imagem, imagem_nova, threshold)\n\n    return imagem_nova\nend\n\n\nbordas_paralelo_v5 = bordas_ParStencil!(imagem, threshold)\n@assert all(bordas .≈ bordas_paralelo_v5)",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>`ParallelStencil`</span>"
    ]
  },
  {
    "objectID": "PART_2/12_benchmarks.html",
    "href": "PART_2/12_benchmarks.html",
    "title": "12  Benchmarks",
    "section": "",
    "text": "Depois de tanto trabalho, Daisy quer comparar todos os métodos e descobrir qual foi solução a mais rápida. Martin, seu mestre, disse que para fazer comparações de códigos que executam rápidamente (menos que 1 segundo) é recomendável utilizar um pacote especializado chamado BenchmarkTools.jl.\nA suricata prontamente utilizou o pacote para comparar todas as funções, e ainda calculou o speed up delas, para saber quantas vezes a função paralela é mais rápida que a solução sequencial.\n\n\n\n\n\n\nSpeedup é compara um valor antigo com o valor novo\n\\[\\text{Speedup} = \\frac{\\text{valor antigo}}{\\text{valor novo}}\\]\n\n\n\n\nusing BenchmarkTools\nimg = imagem\nt = threshold\n\ntempo_execução = zeros(6)\n\ntempo_execução[1] = @belapsed detectar_bordas($img, $t);\ntempo_execução[2] = @belapsed bordas_at_threads($img, $t);\ntempo_execução[3] = @belapsed bordas_at_spawn($img, $t);\ntempo_execução[4] = @belapsed bordas_varias_regiões($img, $t);\ntempo_execução[5] = @belapsed bordas_ThreadsX($img, $t);\ntempo_execução[6] = @belapsed bordas_ParStencil($img, $t);\n\n# primeiro item é a solução sequencial\nspeed_up = tempo_execução[1]./tempo_execução\n\n\nusing UnicodePlots\nnomes_funções = [\"Sequencial\",\n                \"@threads\",\n                \"@spawn\",\n                \"Regiões\",\n                \"ThreadsX\",\n                \"ParStencil\"\n            ]\nfig1 = barplot(nomes_funções, tempo_execução,\n    title=\"Tempo de execução [segundos]\")\nfig2 = barplot(nomes_funções, speedUp,\n    title=\"Speed up\")\n\n# savefig(fig1, \"tempo_execução.txt\")\n# savefig(fig2, \"speed_up.txt\")\n\nOs resultados de Daisy foram:\n\n                     Tempo de execução [segundos]\n              ┌                                        ┐\n   Sequencial ┤■■■■■ 0.0557669\n     @threads ┤■■■■■■■■■ 0.111283\n       @spawn ┤■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■ 0.352736\n      Regiões ┤■■■■■■■■■ 0.10945\n     ThreadsX ┤■■■■■■■■■■ 0.118113\n   ParStencil ┤■■■ 0.0325353\n              └                                        ┘\n                               Speed up\n              ┌                                        ┐\n   Sequencial ┤■■■■■■■■■■■■■■■■■■ 1\n     @threads ┤■■■■■■■■■ 0.501127\n       @spawn ┤■■■ 0.158098\n      Regiões ┤■■■■■■■■■ 0.509519\n     ThreadsX ┤■■■■■■■■■ 0.47215\n   ParStencil ┤■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■ 1.71404\n              └                                        ┘\n\nDaisy ficou surpresa que o código paralelo foi, em geral, mais lento que o sequencial, uma vez que ela sempre escutou o contrário. Martin então explica que programação paralela tem um custo inicial que não é pequeno.\nComo a imagem do seu mapa mundial não tinha gigabytes de tamanho, e a complexidade do algoritmo também foi modesta, a sobrecarga de criar e gerenciar as Threads em paralelo demorou mais tempo que executar 2 loops.\nSomente o seu último código, o bordas_ParStencil, foi o mais rápido, porque ele foi inteligente o suficiente para minimzar a distribuição de tarefas, fazendo valer a pena o paralelismo.",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Benchmarks</span>"
    ]
  },
  {
    "objectID": "PART_3/00_going_for_work.html",
    "href": "PART_3/00_going_for_work.html",
    "title": "Parte 3",
    "section": "",
    "text": "Ao Trabalho\nDaisy está determinada a guardar dinheiro para suas futuras viagens - e quem sabe uma placa de vídeo. Para tal, ela decidiu trabalhar para sua gangue. Sua idéia foi oferecer serviços de babá para recém-nascidos. Ela adora passar um tempo com crianças e acredita que seria uma ótima maneira de ganhar dinheiro enquanto relaxa sob o sol. Contudo, isso não será o suficiente….",
    "crumbs": [
      "Parte 3"
    ]
  },
  {
    "objectID": "PART_3/00_going_for_work.html#processos-distribuídos",
    "href": "PART_3/00_going_for_work.html#processos-distribuídos",
    "title": "Parte 3",
    "section": "Processos Distribuídos",
    "text": "Processos Distribuídos\nEste é o capítulo que trará ferramentas mais ponderosas, e ao mesmo tempo, trará problemas mais complicados, pois os processos paralelos precisam se comunicar. Em Julia o pacote Distributed.jl é a solução para muitos dos problemas que você poderá encontrar.",
    "crumbs": [
      "Parte 3"
    ]
  },
  {
    "objectID": "PART_3/13_pmap.html",
    "href": "PART_3/13_pmap.html",
    "title": "13  pmap",
    "section": "",
    "text": "Cuidar dos suricates recém-nascidos foi super fácil para Daisy. Ela os deixava sair para brincar ou relaxar sob o sol. Mais tarde, quando eles voltaram, ela anotava quanto tempo cada suricate ficou brincando.\nDiferente dos outros programas que ela escreveu, dessa vez cada suricate esta em um local diferente, então seus códigos precisarão ser executados em computadores diferentes, ou seja, sem ajuda de multithreading. Martin diz a Daisy que Julia permite executar Julia em computadores diferentes nativamente (ou seja, não preicsa de outros programas), mas requer atenção aos detalhes. O recomendável é usar o pacote Distributed.jl, pois oferece as funções úteis para a grande maioria dos problemas.\nPara simplificar seus relatórios, Daisy atribuiu a cada suricate um número, começando com 2 (já que ela é o número 1). Ela só permitiu que os recém-nascidos brincassem em quatro áreas seguras vigiadas por 4 workers.\n\n\n\n\n\nDaisy deseja um código simples, cada worker vai informar quanto tempo cada suricate filhote ficou brincando no sol. A função ideal para fazer isso sem nenhum paralelismo é map, e Daisy encontrou sua versão equivalente em Distributed.jl, é a pmap.\n\n\n\n\n\n\nSintaxe: Distributed\n\n\n\n\n\nEsse pacote é responsável por criar novas instâncias de Julia em máquinas remotas. Ficaremos com o caso mais simples, e usaremos apenas os vários Cores do seu processador para emular outros computadores.\n\nusing Distributed\naddprocs(3) # 'criou'/'conectou' com 3 máquinas\n...\nrmprocs() # 'apaga'/'desliga' todas as máquinas\n\n\n\n\n\n\n\n\n\n\nSempre que você encontrar o comando rmprocs em algum exemplo, isso significa que é necessário encerrar a sessão atual de Julia e iniciar uma nova. Isso garante que não haja confusão com a quantidade de processos ativos, e garante que futuros tutoriais funcionem corretamente.\n\n\n\nPara que Daisy só escreva seu código em uma máquina, e copie ele em todas as outras, foi necessário o comando @everywhere. A primeira tentativa de Daisy gerou esse código, e que já funciona corretamente.\n\nusing Distributed\naddprocs(4) # 4 playgrounds\n\n@everywhere function brincar_no_sol(suricate)\n    # Cada suricate passa um tempo aleatório no sol\n    tempo = round( 2rand(), digits=2) # tempo brincando\n    println(\"suricate '$(suricate)' brincou $(tempo) horas\")\n    return tempo\nend\n\nsuricates = [2,3,4,5,6] # os 'nomes' dos suricate são seus 'ids'\nrelatorio = pmap(suricates) do suricate\n    brincar_no_sol(suricate)\nend;\n\n      From worker 2:    suricate '4' brincou 0.41 horas\n      From worker 3:    suricate '2' brincou 0.5 horas\n      From worker 4:    suricate '3' brincou 1.61 horas\n      From worker 5:    suricate '5' brincou 1.41 horas\n      From worker 3:    suricate '6' brincou 1.86 horas",
    "crumbs": [
      "Parte 3",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>`pmap`</span>"
    ]
  },
  {
    "objectID": "PART_3/14_at_spawnat.html",
    "href": "PART_3/14_at_spawnat.html",
    "title": "14  @spawnat",
    "section": "",
    "text": "Depois de implementar seu código usando o paralelismo distribuído, Daisy percebeu que cada suricatinho tinha uma preferência, cada um gostava mais de uma certa região, e Daisy queria respeitar essa preferência. Para tornar o código mais legível, cada suricate foi representado como uma Tupla Nomeada.\n\nsuricates = [(nome=2,região=2),\n            (nome=3, região=2),\n            (nome=4, região=3),\n            (nome=5, região=4),\n            (nome=6, região=4)\n            ]\n\nMas como enviar cada suricate para cada região de preferencia? Para conseguir isso, Daisy voltou a documentação do pacote Distributed.jl, e descobriu a macro @spawnat que faz justamente o que ela buscava.\n\n\n\n\n\n\nSintaxe: @spawnat\n\n\n\n\n\nVocê deve especificar qual o id da máquina que irá executar sua função.\n\nresposta = Distributed.@spawnat id_maquina sua_função(....)\n\nCaso não seja importante o id, poderia usar o comando :any\n\nresposta = Distributed.@spawnat :any sua_função(....)\n\n\n\n\nDiferentemente de multithreading, quando ela executou o código, a resposta não foi o que ela desejava, como foi o caso do pmap, agora com o @spawnat a variável de resposta foi do tipo Future, que servia apenas como ‘nota fiscal’/‘ticket’. Era uma variável que garantia que a tarefa foi enviada ao processo, mas não retornava o valor. Para realmente obter os dados, Daisy precisava usar um comando especial, o fetch.\n\nrelatorio = map(suricates) do s\n    @spawnat s.região brincar_no_sol(s.nome)\nend;\n# Para recuperar a resposta de apenas 1 elemento\n# `fetch(relatorio[1])`\n\ndados_relatorio = fetch.(relatorio)",
    "crumbs": [
      "Parte 3",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>`@spawnat`</span>"
    ]
  },
  {
    "objectID": "PART_3/15_shared_arrays.html",
    "href": "PART_3/15_shared_arrays.html",
    "title": "15  SharedArrays",
    "section": "",
    "text": "15.1 parte_local\nDaisy não trabalhava sozinha, ela era responsável por uma pequena região, de uma grande área, compartilhada com outros suricates. Sua nova chefe, a suricata Jessie, controlava quais regiões cada suricate é autorizado a trabalhar, e cada região eram chamada de parte_local, pois cada suricate só trabalha na sua parte.\nDaisy já tinha fama de programadora, assim foi convocada por Jessie a escrever um código para verificar que cada suricate esta nos seus limites.\nNessa situação, Daisy precisou usar outro pacote, o SharedArrays.jl, pois ela conseguiria representar a área total de excavação como uma variável compartilhada, no qual cada suricate excavador pode ter acesso.\n@everywhere using SharedArrays\nterreno = SharedMatrix{Int}((4,16), pids = workers())\n\n@everywhere function ver_parte_local!(terreno)\n    parte_local = localindices(terreno)\n    println(\"suricate '$(myid())' trabalha em '$(parte_local)'\")\n    terreno[parte_local] .= myid()\nend\nfor w in workers()\n    Distributed.@spawnat w ver_parte_local!(terreno)\nend\nterreno\nComo a área possuia 16 locais de excavação e 4 trabalhadores, a distribuição de tarefas era direta, com cada suricate foi designado para 4 locais.",
    "crumbs": [
      "Parte 3",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>`SharedArrays`</span>"
    ]
  },
  {
    "objectID": "PART_3/15_shared_arrays.html#parte_local",
    "href": "PART_3/15_shared_arrays.html#parte_local",
    "title": "15  SharedArrays",
    "section": "",
    "text": "Sintaxe: localindices\n\n\n\n\n\nMatrizes em Julia armazenam os valores de forma continua na memória como na figura abaixo. \nlocalindices retornou os indices implicitos de cada valor, e não as linhas e colunas.\n\n\n\n\n\n\n\n\n\nSintaxe: myid\n\n\n\n\n\nTodos os processos podem acessar e editar todos os valores da variável terreno porque SharedArrays gerencia a memória para que você não tenha que escrever um código para isso. Nesse exemplo, cada processo apenas anotou seu id, obtido com a função myid.",
    "crumbs": [
      "Parte 3",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>`SharedArrays`</span>"
    ]
  },
  {
    "objectID": "PART_3/15_shared_arrays.html#túneis",
    "href": "PART_3/15_shared_arrays.html#túneis",
    "title": "15  SharedArrays",
    "section": "15.2 Túneis",
    "text": "15.2 Túneis\nAgora que cada suricate conhece seus limites, eles podem começar a escavação dos seus túneis. No entanto os códigos de Daisy tem um requisito muito forte: a representação do túnel em seus códigos não pode ter lacunas entre as camadas, ou seja, cada camada deve ser conectada à anterior.\n\nDaisy chegou numa solução simples, baseada na sua experiência em anotar dias de que poderia sair de casa, ela vai criar uma matriz de zeros representando o terreno, e as áreas escavadas, ela indicou usando 1. Por enquanto Daisy só tem um protótipo, ele funciona apenas para testar que a construção do túnel esta funcionando como deveria no desenho.\n\n\n\n\n\n\nSintaxe: findfirst\n\n\n\n\n\nPara encontrar o 1 na camada superior, Daisy só precisar a posição do único 1 que deverá estar armazenado, para isso Daisy usou a função findfirst\n\n# encontra o primeiro valor '4'\nx = [4,3,4,4,6]\n@show findfirst(x .== 4)\n\ny = [false, false, true, false, true]\n@show findfirst(y);\n\nfindfirst(x .== 4) = 1\nfindfirst(y) = 3\n\n\n\n\n\n\nfunction escavar_tunel!(terreno)\n    linhas, colunas = size(terreno)\n\n    # primeira linha é a linha do solo\n    ponto_partida = rand(1:colunas)\n    terreno[1, ponto_partida] = one(eltype(terreno))\n\n    for i in 2:linhas\n        ultima_posicao = findfirst( terreno[i-1,:] )\n\n        esquerda = ultima_posicao - 1\n        meio = ultima_posicao\n        direita = ultima_posicao + 1\n\n        if esquerda &lt; 1\n            possiveis_posições = [direita, meio]\n        elseif direita &gt; colunas\n            possiveis_posições = [meio, esquerda]\n        else\n            possiveis_posições = [esquerda, meio, direita]\n        end\n\n        local_para_escavar = rand(possiveis_posições)\n        terreno[i, local_para_escavar] = one(eltype(terreno))\n    end\nend\n\nterreno = zeros(Bool, 10, 6)\nescavar_tunel!(terreno)\n\n# Somente para visualização no terminal\nusing SparseArrays\nsparse(terreno)\n\n10×6 SparseMatrixCSC{Bool, Int64} with 10 stored entries:\n ⋅  ⋅  ⋅  ⋅  1  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  ⋅  1  ⋅",
    "crumbs": [
      "Parte 3",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>`SharedArrays`</span>"
    ]
  },
  {
    "objectID": "PART_3/15_shared_arrays.html#terreno-rochoso",
    "href": "PART_3/15_shared_arrays.html#terreno-rochoso",
    "title": "15  SharedArrays",
    "section": "15.3 Terreno Rochoso",
    "text": "15.3 Terreno Rochoso\nEm um certo dia, o local da escavação era mais rochoso que o esperado, e ao mesmo tempo, um dos suricates ficou doente e não podia trabalhar, resultando em uma distribuição desigual de tarefas.\nDaisy foi chamada as pressas, seu protótipo precisa funcionar, e ainda levar em conta a zona de trabalho (parte_local) de cada suricate. Daisy sabia que usar os indices implicitos do SharedArrays não seria útil, a solução foi cada suricate informar carregar consigo em um papel qual sua região de trabalho, ou seja, a parte_local será uma variável de entrada.\n\n@everywhere function escavar_tunel!(terreno, parte_local)\n    qtd_camadas = size(terreno, 1)\n\n    # primeira linha é a linha do solo\n    tamanho_região = length(parte_local)\n    ponto_partida = parte_local[rand(1:tamanho_região)]\n    terreno[1, ponto_partida] = one(eltype(terreno))\n\n    for i in 2:qtd_camadas\n        ulitma_camada = terreno[i-1, parte_local]\n        idx_local = findfirst(ulitma_camada)\n        ultima_posicao = parte_local[idx_local]\n\n        esquerda = ultima_posicao - 1\n        meio = ultima_posicao\n        direita = ultima_posicao + 1\n\n        if esquerda &lt; parte_local[1]\n            possiveis_posições = [direita, meio]\n        elseif direita &gt; parte_local[end]\n            possiveis_posições = [meio, esquerda]\n        else\n            possiveis_posições = [esquerda, meio, direita]\n        end\n\n        local_para_escavar = rand(possiveis_posições)\n        terreno[i, local_para_escavar] = one(eltype(terreno))\n    end\n\n   return nothing\nend\n\n\n# suricate `4` ficou doente\n# então suricate `2` precisou compensar\nrochoso = SharedMatrix{Bool}((16,8+3+6), pids = [2,3,5])\nescavadores = [(nome=2, parte_local=1:8),\n               (nome=3, parte_local=9:11),\n               (nome=5, parte_local=12:17)\n              ]\nfor s in escavadores\n    @spawnat s.nome escavar_tunel!(rochoso, s.parte_local)\nend\n\nsparse(rochoso)\nrmprocs()",
    "crumbs": [
      "Parte 3",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>`SharedArrays`</span>"
    ]
  },
  {
    "objectID": "PART_3/16_distributed_arrays.html",
    "href": "PART_3/16_distributed_arrays.html",
    "title": "16  DistributedArray",
    "section": "",
    "text": "16.1 Novos índices\nFuli também tem experiência com programação, e informa Daisy que seus códigos apesar de bem intencionados, nunca funcionariam na linha de produção, pois SharedArrays.jl é uma solução para emular processos distribuidos, mas exige que os dados sejam compartilhados, ou seja, suas matrizes precisam estar no mesmo computador.\nCaso Daisy queira rodar seus códigos em paralelo de verdade, ela precisa usar o pacote DistributedArrays.jl. Esse pacote facilita a distribuição dos indices de cada trabalhador, mas precisa de um pouco de atenção para acessar os dados corretamente.\nDaisy ficou confusa, mas Fuli lhe deu alguns exemplos básicos. Fuli explica que é necessário criar variáveis distribuidas, do mesmo jeito que Daisy criou uma matriz preenchida com zeros, usando a função zeros, o pacote DistributedArrays.jl disponibiliza alguns comandos semelhantes, mas com um d adicional, tal como dzeros, dones.\nusing Distributed\naddprocs(2)\n\n@everywhere using DistributedArrays\nexemplo = dzeros(Int64, 3, 6)\n\n@everywhere function ver_indices_globais(exemplo)\n\n    Δx, Δy = DistributedArrays.localindices(exemplo)\n    println(\"índices Globais: Δx = $(Δx), Δy = $(Δy)\")\nend\n\nfor w in workers()\n    @spawnat w ver_indices_globais(exemplo)\nend\nsleep(1) # para dar tempo da mensagem aparecer\n\n      From worker 2:    índices Globais: Δx = 1:3, Δy = 1:3\n      From worker 3:    índices Globais: Δx = 1:3, Δy = 4:6\nUma vez que Daisy conhece os índices globais, os índices locais são iguais aos comprimento de cada intervalo. Fuli alerta Daisy, para escrever em matrizes distribuidas, só podem ser utilizados indices locais, e além disso, com uma palavra chave especial, localpart, então Daisy deveria ter cuidado, e não confundir o parte_local que ela já havia criado anteriormente - talvez uma mudança de nome de variáveis seriam bem vindas, Daisy precisaria falar com seu mestre.\n@everywhere function escrever_indice_local!(exemplo)\n\n    Δx, Δy = DistributedArrays.localindices(exemplo)\n    indice_local_x = 1:length(Δx)\n    indice_local_y = 1:length(Δy)\n\n    for x in indice_local_x, y in indice_local_y\n        localpart(exemplo)[x, y] = myid()\n    end\nend\nexemplo = dzeros(Int64, 3, 6)\nfor w in workers()\n    @spawnat w escrever_indice_local!(exemplo)\nend\ndisplay(exemplo);\nrmprocs();\n\n3×6 DArray{Int64, 2, Matrix{Int64}}:\n 2  2  2  3  3  3\n 2  2  2  3  3  3\n 2  2  2  3  3  3",
    "crumbs": [
      "Parte 3",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>`DistributedArray`</span>"
    ]
  },
  {
    "objectID": "PART_3/16_distributed_arrays.html#novos-índices",
    "href": "PART_3/16_distributed_arrays.html#novos-índices",
    "title": "16  DistributedArray",
    "section": "",
    "text": "Sintaxe: distribute\n\n\n\n\n\nCaso você deseje criar uma matriz no localmente, e depois distribui-lá, é só usar o comando disitrubte(matriz)\n\n# encontra o primeiro valor '4'\nA = [1 0 0; 2 0 0; 3 0 0]\ndA = distribute(A)\n\n3×3 DArray{Int64, 2, Matrix{Int64}}:\n 1  0  0\n 2  0  0\n 3  0  0",
    "crumbs": [
      "Parte 3",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>`DistributedArray`</span>"
    ]
  },
  {
    "objectID": "PART_3/16_distributed_arrays.html#novos-tunéis",
    "href": "PART_3/16_distributed_arrays.html#novos-tunéis",
    "title": "16  DistributedArray",
    "section": "16.2 Novos tunéis",
    "text": "16.2 Novos tunéis\nDaisy fez muitos erros, mas finalmente conseguiu, ela adpatou seu código antigo para utilizar o pacote DistributedArrays.jl. Depois de tantos bugs, Daisy chegou a conclusão que é melhor fazer tratamentos de erro, já que quando bugs acontecem em processos remotos, eles não são redirecionados ao processo central, logo, não existem mensagens de erro na tela.\n\n\n\n\n\n\nSintaxe: try\n\n\n\n\n\nUm bloco try-catch funciona como esperado de outras linguagens de programação, sua utilização básica consiste em apenas colocar o seu código dentro do bloco try.\n\ntry\n    sqrt(-1)\ncatch\n    println(\"Não é possível fazer sqrt(-1)\")\n    println(\"Tente sqrt(Complex(-1))\")\nend\n\nNão é possível fazer sqrt(-1)\nTente sqrt(Complex(-1))\n\n\n\n\n\n\nusing Distributed\naddprocs(3)\n@everywhere using DistributedArrays\n\n@everywhere function d_escavar_tunel!(terreno)\n    try\n        Δx, Δy = DistributedArrays.localindices(terreno)\n\n        qtd_camadas = length(Δx)\n        tamanho_região = length(Δy)\n\n        # primeira linha é a linha do solo\n        ponto_partida = rand(1:tamanho_região)\n\n        # '1' == escavar a posição\n        escavar = one(eltype(terreno))\n        localpart(terreno)[1, ponto_partida] = escavar\n\n        for i in 2:qtd_camadas\n            ulitma_camada = localpart(terreno)[i-1, :]\n\n            # garante que o código funcione para outros\n            # tipos de matrizes, além dos tipos `true`/`false`\n            ultima_posicao = findfirst( ulitma_camada .== escavar )\n\n            esquerda = ultima_posicao - 1\n            meio = ultima_posicao\n            direita = ultima_posicao + 1\n\n            if esquerda &lt; 1\n                possiveis_posições = [direita, meio]\n            elseif direita &gt; tamanho_região\n                possiveis_posições = [meio, esquerda]\n            else\n                possiveis_posições = [esquerda, meio, direita]\n            end\n\n            aonde_escavar = rand(possiveis_posições)\n            localpart(terreno)[i, aonde_escavar] = escavar\n        end\n    catch\n        println(\"Aconteceu um Erro.\")\n    end\n\n   return nothing\nend\n\nA construção da matriz distribuída também requer um cuidado adicional, pois é possível controlar quais suricates vão participar da construção do túnel, e em quantas partes cada dimensão da matriz será particionada.\n\n## Preciso passar uma tupla com as dimensões da matriz\ndimensões_terreno = (10, 6)\n\n## Um vetor com os processos que farão o trabalho\nescavadores = workers()\n\n# Cada componente do vetor, corresponde a qtd\n# de particições em cada dimensão. Por exemplo\n# ['1', 2] = eixo 1 não tem divisão\n# [1, '3'] = eixo 2 é divido em 3 partes\ndivisões = [1, 3]\n\n# não tem função que cria matriz booleana,\n# então preciso usar a função `dfill`\nterreno = dfill(false, dimensões_terreno, escavadores, divisões)\n\nfor w in workers()\n    @spawnat w d_escavar_tunel!(terreno)\nend\n\nusing SparseArrays\nsparse(terreno)\n\nrmprocs()",
    "crumbs": [
      "Parte 3",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>`DistributedArray`</span>"
    ]
  },
  {
    "objectID": "PART_3/17_pipeline.html",
    "href": "PART_3/17_pipeline.html",
    "title": "17  pipeline",
    "section": "",
    "text": "17.1 RemoteChannel\nA suricata enfrenta um novo desafio de programação, agora a comunicação entre os processos é crucial. Ela procura a ajuda de Martin e descobre que todos os pacotes anteriores que ela utilizou, já possuiam algum nível de comunicação nos bastidores, mas agora ela precisa aprender esses truques por si mesma. Em Julia, a comunicação entre processos é feita com Channel, e para processos em computadores diferentes, com RemoteChannel.\nMartin alerta Daisy que suas funções precisam virar serviços, ela precisará criar funções que rodam eternamente, apenas esperando por requisições, só assim, ela pipelines funcionarem. A solução mais simples é criar funções dentro de bloco while true ... end.\nDaisy atualizou seu desenho para ser mais técnica, e incluir o que aprendeu.",
    "crumbs": [
      "Parte 3",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>`pipeline`</span>"
    ]
  },
  {
    "objectID": "PART_3/17_pipeline.html#remotechannel",
    "href": "PART_3/17_pipeline.html#remotechannel",
    "title": "17  pipeline",
    "section": "",
    "text": "Sintaxe: remotechannels\n\n\n\n\n\nUm RemoteChannel é um canal de comunicação entre processos que funciona com uma fila, logo, a primeira mensagem a ser colocada, é a primeira ser retirada (FIFO). Todos os processos podem escrever dados com pu!, e efetuar leitura com take!.\n\nusing Distributed\naddprocs(3)\n\n# todos os processos podem\n# ler e escrever até 4 mensagens\nRC = RemoteChannel(() -&gt; Channel(4))\n\n# uso o comando `put!`\n## líder\nput!(RC, \"mensagem 1\")\n\n## trabalhadores\n@spawnat 2 put!(RC, \"mensagem 2\")\n@spawnat 3 put!(RC, \"mensagem 3\")\n@spawnat 4 put!(RC, \"mensagem 4\")\n\n\n# ler dados é com o `take!`\n@everywhere function ler_dado(RC)\n    mensagem = take!(RC)\n    println(mensagem)\nend\n\n# cada processo para faz uma leitura\n## líder\nler_dado(RC);\n\n## trabalhadores\n@spawnat 2 ler_dado(RC);\n@spawnat 3 ler_dado(RC);\n@spawnat 4 ler_dado(RC);\n\nrmprocs()\n\nAtenção Se você pede a leitura dos dados, a execução do programa fica travada esperando pelos dados. Então no exemplo, após a leitura das 4 mensagens, se fosse requisitado uma nova leitura, o código ficaria travado indefinitivamente.\n\n(...)\n@spawnat 3 ler_dado(RC);\n@spawnat 4 ler_dado(RC);\n\n# A fila esta vazia, portanto uma nova leitura\n# iria ficar aguardando infinitamente algum dado\nler_dado(RC)\n\n\n\n\n\n\n\n\n\n\n\nSintaxe: Serviços Remotos\n\n\n\n\n\nVocê vai aproveitar do fato que take! fica aguardando dados por tempo indeterminado, mas não no nó líder (processo 1), mas apenas nos trabalhadores remotos, já que assim não atrapalha a execução do seu programa.\n\nusing Distributed\naddprocs(2)\n\n@everywhere function ler_dado(RC)\n    while true\n        mensagem = take!(RC)\n        sleep(1)\n        println(mensagem)\n    end\n    return nothing\nend\n\n# canal aceita apenas 4 dado por vez\nRC = RemoteChannel(() -&gt; Channel(4))\n\n# apenas o processo '2' ficará\n# travado esperando por dados\n@spawnat 2 ler_dado(RC)\n\nput!(RC, \"mensagem 1\");\nput!(RC, \"mensagem 2\");\n@spawnat 3 put!(RC, \"mensagem 3\");\n@spawnat 3 put!(RC, \"mensagem 4\");\n\nrmprocs()\n\nTask (done) @0x00007f3d6c4892d0",
    "crumbs": [
      "Parte 3",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>`pipeline`</span>"
    ]
  },
  {
    "objectID": "PART_3/17_pipeline.html#nova-escavação",
    "href": "PART_3/17_pipeline.html#nova-escavação",
    "title": "17  pipeline",
    "section": "17.2 Nova Escavação",
    "text": "17.2 Nova Escavação\nCriar túneis acontecerá em 2 estágios, logo, Daisy pegou os códigos antigos, e os adaptou para o novo desafio. Dessa vez ela reparou que poderia ser muito mais eficiente. Se no lugar ter uma matriz com 0 e 1, ela poderia ter apenas um vetor contendo a posição exata da escavação (apenas a posição do indice aonde ficaria registrado o valor 1).\nAbaixo, Daisy escreveu seu código para as primeiras etapas.\n\nusing Distributed\naddprocs(3)\n\n@everywhere function etapa_1(qtd_camadas, tamanho_região, RC_entrada, RC_saida)\n    while true\n        ponto_partida = take!(RC_entrada)\n        println(\"[Começou] Primeira Etapa\")\n\n        pontos_escavação = [ponto_partida]\n        escavar!(pontos_escavação, qtd_camadas, tamanho_região)\n\n        put!(RC_saida, pontos_escavação)\n        println(\"[Terminado] Primeira Etapa\")\n    end\nend\n\n@everywhere function etapa_2(qtd_camadas, tamanho_região, RC_entrada, RC_saida)\n    while true\n        # recebe as etapas anteriores\n        pontos_escavação = take!(RC_entrada)\n        println(\"[Começou] Segundo Etapa\")\n\n        escavar!(pontos_escavação, qtd_camadas, tamanho_região)\n\n        put!(RC_saida, pontos_escavação)\n        println(\"[Terminado] Segundo Etapa\")\n    end\nend\n\n@everywhere @inline function escavar!(pontos_escavação, qtd_camadas, tamanho_região)\n\n    for i in 2:qtd_camadas\n        ultima_posicao = pontos_escavação[end]\n\n        esquerda = ultima_posicao - 1\n        meio = ultima_posicao\n        direita = ultima_posicao + 1\n\n        if esquerda &lt; 1\n            possiveis_posições = [direita, meio]\n        elseif direita &gt; tamanho_região\n            possiveis_posições = [meio, esquerda]\n        else\n            possiveis_posições = [esquerda, meio, direita]\n        end\n        aonde_escavar = rand(possiveis_posições)\n        push!(pontos_escavação, aonde_escavar)\n    end\n    return nothing\nend",
    "crumbs": [
      "Parte 3",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>`pipeline`</span>"
    ]
  },
  {
    "objectID": "PART_3/17_pipeline.html#mapa-de-profundidade",
    "href": "PART_3/17_pipeline.html#mapa-de-profundidade",
    "title": "17  pipeline",
    "section": "17.3 Mapa de Profundidade",
    "text": "17.3 Mapa de Profundidade\nPara a terceira fase, Fuli precisava de um mapa agradável aos olhos, já que ele iria apresentar os resultados em formato de relatório aos investidores - e suricates investidores também tem medo de ver números brutos.\nBaseada em sua experiência com detecção de bordas, Daisy decidiu criar um mapa pintado de vermelho aonde foi escavado, e quanto mais profundo, mais escuro ficam as cores.\n\n@everywhere using Images\n@everywhere function etapa_3(qtd_camadas, tamanho_região, RC_entrada, RC_saida)\n    while true\n        # recebe o túnel completo\n        pontos_escavação = take!(RC_entrada)\n        println(\"[Começou] Terceira Etapa\")\n\n        # mais profundo == mais escuro\n        alphas = range(1.0, 0.25, length = 2qtd_camadas)\n        mapa = [RGBA(1.0, 1.0, 1.0, 1.0)\n            for i ∈ 1:2qtd_camadas, j ∈ 1:tamanho_região]\n\n        for i in eachindex(pontos_escavação)\n            # mostra a divisão entre etapas\n            # com uma cor diferente\n            if i == qtd_camadas\n                mapa[i, :] .= RGBA(1.0, 1.0, 1.0, 0.7)\n            end\n\n            mapa[i, pontos_escavação[i]] = RGBA(1.0, 0.0, 0.0, alphas[i])\n        end\n\n        put!(RC_saida, mapa)\n        println(\"[Terminado] Terceira Etapa\")\n    end\nend",
    "crumbs": [
      "Parte 3",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>`pipeline`</span>"
    ]
  },
  {
    "objectID": "PART_3/17_pipeline.html#fuli",
    "href": "PART_3/17_pipeline.html#fuli",
    "title": "17  pipeline",
    "section": "17.4 Fuli",
    "text": "17.4 Fuli\nDaisy pegou seu último desenho e o traduziu para códigos. Ela precisava de 4 canais remotos. Uma vez criados, ela notificou cada suricate com as dimensões do projeto, para que eles ficassem aguardando instruções.\n\nRC_1 = RemoteChannel(() -&gt; Channel(1))\nRC_2 = RemoteChannel(() -&gt; Channel(1))\nRC_3 = RemoteChannel(() -&gt; Channel(1))\nRC_4 = RemoteChannel(() -&gt; Channel(1))\n\nqtd_camadas, comprimento = 25, 30\n@spawnat 2 etapa_1(qtd_camadas, comprimento, RC_1, RC_2)\n@spawnat 3 etapa_2(qtd_camadas, comprimento, RC_2, RC_3)\n@spawnat 4 etapa_3(qtd_camadas, comprimento, RC_3, RC_4)\n\nCom tudo preparado, Fuli apareceu, e disse que o ponto de partida de escavação seria bem no centro do terreno.\n\npartida_da_escavação = 15\nput!(RC_1, partida_da_escavação)\n\nNo final do dia, Fuli estava de volta, agora ele queria o mapa dos resultados, antes que todos os suricates fossem dispensados para casa.\n\nmapa_tunel = take!(RC_4)\nsave(\"tunnel_map.png\", mapa_tunel)\n\nrmprocs()\n\nAbaixo, segue um exemplo de túnel escavado da parte superior até a inferior, e a linha cinza indica a transição de um suricate para outro.",
    "crumbs": [
      "Parte 3",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>`pipeline`</span>"
    ]
  },
  {
    "objectID": "PART_3/18_spmd.html",
    "href": "PART_3/18_spmd.html",
    "title": "18  Primeiro Teste",
    "section": "",
    "text": "18.1 Segundo Teste\nDaisy consegue comunicar a todos a respeito da ameaça, mas como que ela vai saber quem irá ajudar a combate-lá? Para isso, ela precisou dos comandos sendto e recvfrom - ‘enviar para’ e ‘receber de’ em uma tradução livre. Seu novo código é uma modificação do anterior, para ter certeza que todos os Sentinelas conseguem enviar mensagens.\n@everywhere function spmd_teste_send_recv()\n    # primeiro encontra a cobra\n    if myid() == 2\n        println(\"$(myid()) achou a cobra\")\n        cobra = 2\n    else\n        cobra = nothing\n    end\n\n    # notifica todos os sentinelas\n    aonde_esta_cobra = bcast(cobra, 2)\n    barrier(;pids=[2,3,4])\n\n    # dependendo do nome, a sentinela toma\n    # uma ação diferente\n    if myid() ≠ 2\n        # outras sentinelas dizem que escutaram\n        mensagem = \"$(myid()) entendeu o recado\"\n        sendto(aonde_esta_cobra, mensagem)\n    elseif myid() == 2\n        # sentinela 2 fica esperando todas\n        # falaram que entenderam\n\n        outras_sentinelas = [3,4]\n        for sentinela = outras_sentinelas\n            mensagem = recvfrom(sentinela)\n            println(mensagem)\n        end\n    end\n    barrier(;pids=[2,3,4])\n\n    nothing\nend\n\nspmd(spmd_teste_send_recv; pids=workers())\nrmprocs();",
    "crumbs": [
      "Parte 3",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Primeiro Teste</span>"
    ]
  },
  {
    "objectID": "PART_3/18_spmd.html#último-teste",
    "href": "PART_3/18_spmd.html#último-teste",
    "title": "18  Primeiro Teste",
    "section": "18.2 Último Teste",
    "text": "18.2 Último Teste\nAgora Daisy tem condições de fazer um código realistico.\nQuando uma cobra é avistada, todos os sentinelas são notificados. Todos os suriciates deveriam ir até a serpente para formar um pequeno exército. Contudo, alguns suricates têm medo, e permanecem em suas posições.\nSe a maioria comparecer ao local, o exército consegue fazer gritos o suficiente para espantar o inimigo. Do contrário, a cobra terá um suricate no seu cardápio.\n\n\n\n\n\nO código final de Daisy levou tudo isso em conta, cada sentinela tem 50% de chance de enfrentar a cobra - do mesmo jeito que seus pais lhe faziam ficar em casa.\n\nusing Distributed\naddprocs(5)\n@everywhere using DistributedArrays\n@everywhere using DistributedArrays.SPMD\n\n@everywhere function spmd_snake_drill()\n    sentinela = myid()\n    if sentinela == 2\n        cobra = 2\n        println(\"Sentinela '$(sentinela)' avistou uma cobra.\")\n    else\n        cobra = nothing\n    end\n\n    # notificar todos os sentinelas\n    aonde_esta_cobra = bcast(cobra, 2)\n    barrier(;pids=[2,3,4,5,6])\n\n\n    if sentinela ≠ 2\n        exercito = nothing\n        println(\"Sentinela '$(sentinela)' escutou o recado...\")\n        if rand() &gt; 0.5\n            println(\" e '$(sentinela)' pode ajudar.\")\n            podeAjudar = true\n            sendto(aonde_esta_cobra, podeAjudar)\n        else\n            println(\" e '$(sentinela)' não pode ajudar.\")\n            podeAjudar = false\n            sendto(aonde_esta_cobra, podeAjudar )\n        end\n    elseif sentinela == 2\n        # todos os membros do exército\n        exercito = [2] # o sentinela 2 vai participar\n\n        outras_sentinelas = [3,4,5,6]\n        for sentinela = outras_sentinelas\n            podeAjudar = recvfrom(sentinela)\n            if podeAjudar\n                push!(exercito, sentinela)\n                println(\"'$(sentinela)' chegou para ajudar.\")\n            end\n        end\n        println(\"O exército $(exercito) irá lutar!\")\n        println(\"-------\")\n    end\n    barrier(;pids=[2,3,4,5,6])\n\n\n    if sentinela == 2\n        qtd_suricates = 5\n        ## Se a maioria dos suricates estiver\n        ## no exército, eles ganham\n        if length(exercito) &gt; qtd_suricates÷2\n            println(\"--&gt; Exército venceu.\")\n            println(\"A cobra foi derrotada.\")\n        else\n            println(\"--&gt; O exército perdeu.\")\n            println(\"A cobra teve sua refeição.\")\n        end\n    end\n    nothing\nend\n\nspmd(spmd_snake_drill; pids=workers())\nrmprocs();",
    "crumbs": [
      "Parte 3",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Primeiro Teste</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Paralelismo com Suricates",
    "section": "",
    "text": "Bem-vindo\nEsta é uma série de tutoriais sobre programação paralela em Julia, apresentados em formato de narrativa semelhante a uma história. Portanto, todo o código apresentado está interligado.\nSe você já possui experiência em programação e está interessado em explorar a linguagem Julia por suas incríveis capacidades de programação paralela, este curso é ideal para você! Vamos focar especialmente na sintaxe básica de várias funcionalidade,, sem sobrecarregar com algoritmos paralelos mais complexos.\nEspero que goste e, mais importante, que aprenda algo novo.\n\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.",
    "crumbs": [
      "**Bem-vindo**"
    ]
  },
  {
    "objectID": "PART_1/04_inline.html#assert",
    "href": "PART_1/04_inline.html#assert",
    "title": "4  A Competição",
    "section": "4.2 @assert",
    "text": "4.2 @assert\n@assert é uma macro usada para verificar se uma determinada condição é verdadeira, se sim, a macro não faz nada. Senão, ela manifesta um erro\n\n\n\n\n\n\n@assert\n\n\n\n\n\n\nfunction teste_valor(x)\n    @assert x &gt; 5\n    return \"OK\"\nend\n@show teste_valor(10)\nbegin\n    try\n        teste_valor(1)\n    catch\n        println(\"Função falhou, e precisou de tratamento.\")\n    end\nend;\n\nteste_valor(10) = \"OK\"\nFunção falhou, e precisou de tratamento.\n\n\n\n\n\n\n\n\n\n\n\nExercício 4.2\n\n\n\n\n\nQual a condição para que a linha abaixo produza um erro\n\n@assert 1 == _____\n\n\n\n\n\n\n\n\n\n\nSolução 4.2\n\n\n\n\n\nQualquer valor que retorne uma comparação false, por exemplo, com um número qualquer diferente de 1, ou usar tipos que não tem comparação válidos (Integer e String por exemplo).\n\n@show @assert 1 == 0 # AssertionError \n@show @assert 1 == \"1\" # AssertionError",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>A Competição</span>"
    ]
  },
  {
    "objectID": "PART_1/04_inline.html#inline",
    "href": "PART_1/04_inline.html#inline",
    "title": "4  A Competição",
    "section": "4.3 inline",
    "text": "4.3 inline\n\n\n\n\n\n\nExemplo\n\n\n\n\n\nNo lugar de uma função criar a variável de retorno\n\nfunction criar_output(input)\n    linhas, colunas = size(input)\n    output = zeros(linhas, colunas)\n\n    for i eachindex(output)\n        output[i] = 2*i\n    end\n    return output\nend\n\nVocê pode criar a variável de saída separadamente, e ela será utilizada como variável de entrada\n\nfunction criar_output!(input, output)\n    for i eachindex(output)\n        output[i] = 2*i\n    end\n    return output\nend\n\nlinhas, colunas = size(input)\noutput = zeros(linhas, colunas)\ncriar_output!(input, input)\n\n\n\n\nEla decidiu fazer isso, pois ela descobriu que em Julia, qualquer funçõa pode alterar o valor de vetores ou matrzes, mas para evitar confusão, é costume nomear funções que modificam suas entradas com um ! no final do nome, assim, Daisy critou a função calendario_mensal!.\nDaisy queria aproveitar uma função para calcular a agenda semanal de todos os meses, mas Martin, seu mestre, explicou que isso não é uma boa ideia, já que cada mês tem uma quantidade diferente de semanas. Então, eles decidiram criar uma solução simples para fevereiro, que geralmente tem 28 dias ou 4 semanas de 7 dias. Daisy criou uma função que gerava um erro se a matriz com as respostas não tivesse as dimensões corretas, usando a macro @assert - essa macro garante que a função não funcione se as dimensões da matriz estiverem erradas.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>A Competição</span>"
    ]
  },
  {
    "objectID": "PART_1/04_inline.html#tipos-genéricos",
    "href": "PART_1/04_inline.html#tipos-genéricos",
    "title": "4  A Competição",
    "section": "4.4 Tipos Genéricos",
    "text": "4.4 Tipos Genéricos\nAs funções one e zero são usadas para obter a representação do número um e do número zero, respectivamente, para um determinado tipo de dados. Isso é útil em muitas operações in-place, onde você deseja garantir que a operação respeite os tipos das variáveis que serão alteradas.\nO parâmetro de entrada em one(x)/zero(x) é o tipo desejado, se você não sabe o tipo de uma variável, pode descobri-lo com eltype.\n\n\n\n\n\n\none\n\n\n\n\n\n\n@show one(Int64)\n@show one(Float64)\n@show one(Bool)\n@show one(eltype(1.0)); ## equivalent to 'one(Float64)'\n\none(Int64) = 1\none(Float64) = 1.0\none(Bool) = true\none(eltype(1.0)) = 1.0\n\n\n\n\n\n\n\n\n\n\n\nExercício 4.5\n\n\n\n\n\nIdentifique o erro e a solução do código a seguir\n\nmes = zeros(Bool, 4, 7)\nu = eltype(mes)\nT = one(u)\nF = zeros(u)\n\n\n\n\n\n\n\n\n\n\nSolução 4.5\n\n\n\n\n\nExiste um erro de grafia para a criação da variável F. As funções zero e zeros retornam objetos diferentes, mesmo com nomes semelhantes. zero retorna um valor, e zeros retorna um vetor ou matriz.\n\nF = zeros(u) # errada\nF = zero(u) # certo",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>A Competição</span>"
    ]
  },
  {
    "objectID": "PART_1/04_inline.html#documentação",
    "href": "PART_1/04_inline.html#documentação",
    "title": "4  A Competição",
    "section": "",
    "text": "docstrings\n\n\n\n\n\n\n\"retorna tipo da matriz de entrada\"\nqual_tipo(x::Matrix) = eltype(x)\n\n\n\n\n\n\n\n\n\n\n\n\nExercício 4.1\n\n\n\n\n\nEscreva a docstring apropriado, baseada na finalidade do código a seguir, e acesse a documentação via REPL\n\n\"__________________________\"\nsalvar(a::String, b) =  write(\"$(a).txt\", b)\n\n\n\n\n\n\n\n\n\n\nSolução 4.1\n\n\n\n\n\n\n\"criar um arquivo `a`.txt e salvar o valor de `b`\"\nsalvar(a::String, b::String) =  write(\"$(a).txt\", b)\n\n\njulia&gt;?salvar\n\n\nhelp&gt;salvar",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>A Competição</span>"
    ]
  },
  {
    "objectID": "PART_1/04_inline.html#in-place",
    "href": "PART_1/04_inline.html#in-place",
    "title": "4  A Competição",
    "section": "4.3 in-place",
    "text": "4.3 in-place\nOperações in-place são aquelas que modificam diretamente os dados de entrada, em vez de criar novos dados. Isso pode ser útil para melhorar a eficiência do código, especialmente quando se trabalha com grandes conjuntos de dados, pois pode reduzir a quantidade de memória necessária, em especial com Manipulações Matriciais.\nEm Julia, as funções têm a capacidade de modificar qualquer um dos argumentos de entrada. Existe uma convenção na linguagem, que é uma regra não oficial, mas amplamente aceita, que estipula que as funções que modificam seus argumentos de entrada devem ser indicadas com um !. Isso serve para alertar os usuários sobre o comportamento potencialmente mutável da função.\n\n\n\n\n\n\n\nfunction letra_minuscula!(entrada, saida)\n    for (idx, texto) in enumerate(entrada)\n        saida[idx] = lowercase(texto)\n    end \n    return nothing\nend\nentrada = [\"SEG\", \"TER\", \"QUAR\"]\nsaida = fill(\"\", size(entrada))\n\nletra_minuscula!(entrada, saida)\ndisplay(saida)\n\n3-element Vector{String}:\n \"seg\"\n \"ter\"\n \"quar\"\n\n\n\n\n\nComo Daisy passou a matriz que será atualizada (mes), ela chamou sua função de agenda_fevereiro! e não agenda_fevereiro.\nImportante: A notação mais comum de operação in-place é com .=\n\n\n\n\n\n\n\nentrada = [\"SEG\", \"TER\", \"QUAR\"]\nentrada .= \"QUI\"\ndisplay(entrada)\n\n3-element Vector{String}:\n \"QUI\"\n \"QUI\"\n \"QUI\"\n\n\n\n\n\n\n\n\n\n\n\nExercício 4.3\n\n\n\n\n\nSimplifique o código a seguir\n\nA = [1 2; 3 4]\nB = [5 6; 7 8]\nfor i in eachindex(A)\n    A[i] += B[i]\nend\n\n\n\n\n\n\n\n\n\n\nSolução 4.3\n\n\n\n\n\n\nA = [1 2; 3 4]\nB = [5 6; 7 8]\nA .+= B\n\n\n\n\n\n\n\n\n\n\nExercício 4.4\n\n\n\n\n\nNo código a seguir, o . possui 2 significados, os identifique, explique, e reescreva uma função que realize a mesma operação, mas sem nenhum .\n\nentrada = [\"SEG\", \"TER\", \"QUAR\"]\nsaida = fill(\"\", size(entrada))\nsaida .= lowercase.(entrada)\n\n\n\n\n\n\n\n\n\n\nSolução 4.4\n\n\n\n\n\nO primeiro ., em .=, tem o sentido de operação é in-place. Enquanto o lowercase. indica a operação elemento-a-elemento.\nNota que funções que alteram valor de entrada precisam ter ! no nome.\n\nfunction obter_lowercase!(entrada, saida)\n    for (idx, texto) in enumerate(entrada)\n        saida[idx] = lowercase(texto)\n    end\n    return nothing\nend",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>A Competição</span>"
    ]
  }
]