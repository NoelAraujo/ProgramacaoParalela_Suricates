[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programação Paralela em Julia: uma História com Suricates",
    "section": "",
    "text": "Bem-vindo\nEsta é uma série de tutoriais sobre programação paralela em Julia, apresentados em formato de narrativa semelhante a uma história. Portanto, todo o código apresentado está interligado com a história.\nEspero que goste e, mais importante, que aprenda algo novo.\n\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books."
  },
  {
    "objectID": "PART_1/00_intro_story.html#a-caçada",
    "href": "PART_1/00_intro_story.html#a-caçada",
    "title": "Parte 1",
    "section": "A Caçada",
    "text": "A Caçada\nEra uma vez, em uma vasta savana repleta de capim alto e acácias espalhadas, vivia Daisy, uma suricata curiosa e aventureira.\n\nEla está aprendendo programação para se tornar uma hacker, então, ela converte suas atividades diárias em programas.\nDaisy também adora explorar o mundo e comer insetos, mas sempre precisa de autorização dos seus pais."
  },
  {
    "objectID": "PART_1/00_intro_story.html#sintaxe",
    "href": "PART_1/00_intro_story.html#sintaxe",
    "title": "Parte 1",
    "section": "Sintaxe",
    "text": "Sintaxe\n\n\n\n\n\n\nTodos os comandos apresentados agora são para lhe familiarizar com a sintaxe de Julia, e, todos os comandos serão utilizadas de uma forma ou outra nos próximos capitulos.\n\n\n\nDurante o texto serão apresentadas sintaxes para comandos pertinentes ao código de Daisy. Eles poderão estar no meio do texto e colapsados, basta clickar no icone para expandir o texto.\n\n\n\n\n\n\nSintaxe: if\n\n\n\n\n\n\nif condição_1 == true\n    ....\nelseif condição_2 == true\n    ....\nelse\n    ....\nend\n\nSe a condição_1 já for uma variável booleana (já é true/false), a comparação pode ser omitidida\n\nif condição_1\n    ....\nelseif condição_2\n    ....\nelse\n    ....\nend\n\n\n\n\nSe a informação for muito relevante, ela pode estar expandida e com outra coloração.\n\n\n\n\n\n\nSintaxe: for\n\n\n\n\n\nDado uma coleção qualquer, normalmente um Vetor, você pode acessar cada elemento da seguinte forma\n\nfor x in coleção\n    ....\nend\n\nOutra alternativa é ter uma variavel com o indice de cada elemento\n\nfor idx in eachindex(coleção)\n    elemento = coleção[idx]\n    ....\nend\n\nA maneira recomenda é produzir indices e valores de uma vez com enumerate\n\nfor (idx, valor) in enumerate(coleção)\n    ....\nend\n\n\n\n\nAlguns códigos terão seus resultados exibidos abaixo do código fonte, para você ter certeza que seus resultados estão consistentes com o esperado.\n\n@show \"Eu sou Daisy\"\npeso = 500 # em gramas\n@show peso/1000; # em kg\n\n\"Eu sou Daisy\" = \"Eu sou Daisy\"\npeso / 1000 = 0.5"
  },
  {
    "objectID": "PART_1/01_for_if.html",
    "href": "PART_1/01_for_if.html",
    "title": "1  for and if",
    "section": "",
    "text": "Um dia, Daisy decidiu que queria sair e caçar alguns lanches. Então, ela foi até os pais e pediu permissão.\nOs pais de Daisy responderam com um simples sim ou não aleatoriamente. Implacável, ela perguntava aos pais todos os dias, esperando que eles eventualmente dissessem sim.\nPara ajudá-la a acompanhar suas permissões de busca diárias, Daisy criou um aplicativo de celular que diariamente pergunta se ela pode caçar aos seus pais. E para ela conseguir se planejar, o aplicativo já faz a mesma pergunta para todos os dias da semana.\nAbaixo esta uma simplificação do código de Daisy, escrito em Julia. O código usava um loop for para percorrer cada dia da semana e um gerador de números aleatórios para determinar se Daisy tinha ou não permissão para sair de casa naquele dia.\n\ndias_da_semana = [\"Segunda\",\"Terça\", \"Quarta\", \"Quinta\", \"Sexta\",\"Sábado\", \"Domingo\"]\n\nfor dia in dias_da_semana\n    # Daisy consegue permissão para sair\n    # de casa com probabilidade 50%\n    permissão = rand() < 0.5\n    if permissão == true\n        println(\"Daisy PODE CAÇAR na $(dia)\")\n    else\n        println(\"Daisy FICA EM CASA na $(dia)\")\n    end\nend"
  },
  {
    "objectID": "PART_1/02_function.html",
    "href": "PART_1/02_function.html",
    "title": "2  function",
    "section": "",
    "text": "Daisy percebeu que seus códigos estavam ficando maiores e complexos, então ficou inevitável a criação de funções.\n\n\n\n\n\n\nSintaxe: Funções\n\n\n\n\n\nExistem 3 maneiras de criar funções em Julia.\n\nA primeira já foi apresentada no código, usando o function.\n\n\nfunction nome_função(nome_input)\n    ....\nend\n\n\nA segunda maneira é apenas o nome da função. Essa sintaxe é útil para comandos de uma única linha.\n\n\nnome_função(nome_input) = ....\n\n\nTerceira maneira é com funções anônimas, isto é, sem nomes, que são indicadas com ->, e só possue variável de entrada.\n\n\nnome_input -> ....\n\n\n\n\nEla criou a função calendario_semanal, que recebe um vetor com os dias_da_semana, e verifica para cada dia se ela terá permissão para caçar.\n\nfunction calendario_semanal(dias_da_semana)\n    qtd_dias = length(dias_da_semana)\n\n    # Daisy está pessimista (em nenhum dia ela poderá caçar)\n    agenda_semanal = [\"não\" for dia in dias_da_semana]\n\n    for indice_do_dia in 1:qtd_dias\n        permissão = rand() < 0.5\n        if permissão == true\n            agenda_semanal[indice_do_dia] = \"sim\"\n        end\n    end\n\n    dias_q_pode_caçar = findall(agenda_semanal .== \"sim\")\n    nomes_dias_q_pode_caçar = dias_da_semana[dias_q_pode_caçar]\n\n    return nomes_dias_q_pode_caçar\nend\ncalendario_semanal(dias_da_semana)\n\nEm seu código, Daisy começou pessimista, assumindo que em toda a semana ela ficará em casa. Mas então, ela não desiste, e pergunta aos pais se ela poderá ou não sair, se sim, ela atualiza sua agenda, senão, ela pelo menos não fica decepcionada.\nNo final, Daisy não quer deixar anotado na sua agenda os dias que ficará em casa, para não ficar chateada. Então ela quer que a função retorne apenas os dias de caçada. Isso quer dizer, que ela precisa encontrar no vetor agenda_semanal, todos os indices que contém o valor sim.\nDepois de identificado os indices dos dias, a função retorna apenas o nome dos dias da semana.\n\n\n\n\n\n\nSintaxe: Operação Elemento-a-Elemento\n\n\n\n\n\nO ponto . antes de um operador significa que o operador será aplicada em todos os elementos do vetor. A seguir um exemplo com o operador comparação ==\n\nA = [\"a\", \"b\", \"a\", \"c\"]\n@show A .== \"a\"\n@show findall(A .== \"a\");\n\nA .== \"a\" = Bool[1, 0, 1, 0]\nfindall(A .== \"a\") = [1, 3]"
  },
  {
    "objectID": "PART_1/03_map.html",
    "href": "PART_1/03_map.html",
    "title": "3  map",
    "section": "",
    "text": "Daisy está sempre procurando maneiras de melhorar seu código e torná-lo mais eficiente. Seu objetivo é melhorar continuamente, e se tornar uma programadora tão habilidosa quanto seu mestre, o lendário hacker suricate, Martin.\nEla descobriu a função map. Sua vantagem é que em vez de criar um vetor com vários não e modificar seus elementos, ela poderia usar o map para executar uma função e já criar os valores desejados.\n\n\n\n\n\n\nSintaxe: map\n\n\n\n\n\nA função map espera aplicar uma função f a cada elemento de uma coleção coll.\n\nf(x) = ....\nmap(f, coll)\n\n# or\nmap( x->f(x), coll)\n\nVocê normalmente não quer definir novas funções a cada vez que for usar esse comando, então existe a sintaxe do\n\nmap(coll) do x\n    f(x)\nend\n\n\n\n\nO novo código de Daisy ficou levemente mais curto, pois agora não precisa ser pessimista, criando um vetor com não e o modificando para incluir sim. Ela terá um vetor com sim ou não automaticamente.\n\nfunction calendario_semanal_map(dias_da_semana)\n\n    agenda = map(eachindex(dias_da_semana)) do indice_do_dia\n        permissão = rand() < 0.5\n        if permissão == true\n            \"sim\"\n        else\n            \"não\"\n        end\n    end\n\n    dias_q_pode_caçar = findall( agenda .== \"sim\" )\n    nomes_dias_q_pode_caçar = dias_da_semana[dias_q_pode_caçar]\n    return nomes_dias_q_pode_caçar\nend\ncalendario_semanal_map(dias_da_semana)"
  },
  {
    "objectID": "PART_1/04_inline.html",
    "href": "PART_1/04_inline.html",
    "title": "4  Inplace Operations",
    "section": "",
    "text": "Daisy ficou emocionada com seu progresso na criação da sua agenda semanal, e decidiu fazer um programa para o mês inteiro. Porém, dessa vez, ela quer fazer algo diferente. Ela quer usar uma variável como Input, aonde serão armazenados os resultados.\n\n\n\n\n\n\nExemplo\n\n\n\n\n\nNo lugar de uma função criar a variável de retorno\n\nfunction criar_output(input)\n    linhas, colunas = size(input)\n    output = zeros(linhas, colunas)\n\n    for i eachindex(output)\n        output[i] = 2*i\n    end\n    return output\nend\n\nVocê pode criar a variável de saída separadamente, e ela será utilizada como variável de entrada\n\nfunction criar_output!(input, input)\n    for i eachindex(output)\n        output[i] = 2*i\n    end\n    return output\nend\n\nlinhas, colunas = size(input)\noutput = zeros(linhas, colunas)\ncriar_output!(input, input)\n\n\n\n\nEla decidiu fazer isso, pois ela descobriu que em Julia, qualquer funções pode alterar o valor de vetores ou matrzes, mas para evitar confusão, é costume nomear funções que modificam suas entradas com um ! no final do nome, assim, Daisy critou a função calendario_mensal!.\nDaisy queria aproveitar uma função para calcular a agenda semanal de todos os meses, mas Martin, seu mestre, explicou que isso não é uma boa ideia, já que cada mês tem uma quantidade diferente de semanas. Então, eles decidiram criar uma solução simples para fevereiro, que geralmente tem 28 dias ou 4 semanas de 7 dias. Daisy criou uma função que gerava um erro se a matriz com as respostas não tivesse as dimensões corretas, usando a macro @assert - essa macro garante que a função não funcione se as dimensões da matriz estiverem erradas.\n\n\n\n\n\n\nSintaxe: @assert\n\n\n\n\n\n@assert só se manifesta como um erro se a condição for false, do contrário, ela não faz nada.\n\nfunction teste_valor(x)\n    @assert x > 5\n    return \"OK\"\nend\n@show teste_valor(10)\nbegin\n    try\n        teste_valor(1)\n    catch\n        println(\"Função falhou, e precisou de tratamento.\")\n    end\nend;\n\n\n\n\nMais uma dica do seu mestre, era para não armazenar sim ou não nas matrizes, já que isso ocupa muita memória, e em aplicativos mobile, Daisy deveria se preocupar em ter programas muito leves. A solução é armazenar apenas 0 ou 1. Contudo, essa solução não é perfeita, e se Daisy precisasse no futuro armazenar 0.0 e 1.0 ? Felizmente em Julia é possível resolver isso criando variáveis do tipo certo, no lugar de criar o valor 1, Daisy usou a função one(), que criar um 1 do tipo da variável que ele recebe na entrada, esse 1 correto, Daisy chamou de sim.\n\n\n\n\n\n\nSintaxe: one()\n\n\n\n\n\none recebe um tipo, se você não sabe o tipo de uma variável, pode descobri-lo com eltype.\n\n@show one(Int64)\n@show one(Float64)\n@show one(Bool)\n@show one(eltype(1.0))\n\n@show one(eltype(1.0)) == one(Float64);\n\none(Int64) = 1\none(Float64) = 1.0\none(Bool) = true\none(eltype(1.0)) = 1.0\none(eltype(1.0)) == one(Float64) = true\n\n\n\n\n\nDaisy então escreveu\n\nfunction agenda_mensal!(agenda_fevereiro)\n    qtd_semanas, qtd_dias = size(agenda_fevereiro)\n\n    # verifica que a matriz de entrada é de fevereiro\n    # se alguma confição for falsa, trava o código\n    @assert qtd_dias == 7\n    @assert qtd_semanas == 4\n\n    # o 'sim' pode ser de qualquer tipo\n    sim = one(eltype(agenda_fevereiro))\n\n    for i = 1:qtd_semanas\n        for j = 1:qtd_dias\n            permissão = rand() < 0.5\n            if permissão == true\n                agenda_fevereiro[i,j] = sim\n            end\n        end\n    end\n    return nothing\nend\nagenda_fevereiro = zeros(Bool, 4, 7)\nagenda_mensal!(agenda_fevereiro)\n\ndisplay(agenda_fevereiro)"
  },
  {
    "objectID": "PART_1/05_named_tuples.html",
    "href": "PART_1/05_named_tuples.html",
    "title": "5  Tuplas Nomeadas",
    "section": "",
    "text": "Daisy já sabe quais dias terá suas aventuras, para guardar seus momentos mágicos, ela quer guardar os insetos que ela caçará. Um banco de dados é muito complexo nesse momento, ela prefere Tuplas Nomeadas, porque seus códigos ficam mais fáciis de interpretar.\n\n\n\n\n\n\nSintaxe: Named Tuple\n\n\n\n\n\nTupla Nomeada são variáveis que são armazenadas juntas, e você não poderá alterar seus valores depois.\n\na = 1\nb = 2\nc = (variavel_a = a, variavel_b = b)\n@show c.variavel_a, c.variavel_b\n\n# ou apenas 1 elemento usa a virgula\nc = (variavel_a = a, );\n\n(c.variavel_a, c.variavel_b) = (1, 2)\n\n\n\n\n\nA caçada é variada, o Menu consiste de 4 insetos, besouro, aranhas, escorpiões, gafanhotos, e a cada caçada, Daisy tem a mesma chance de obter um inseto.\n\n\n\n\n\n\nSintaxe: rand\n\n\n\n\n\nPor padrão a função rand() gera valores aleatórios entre 0 e 1, mas você pode dar um vetor, e a função irá gerar valores aleatórios baseados no conteúdo do vetor.\n\nx = [\"aranha\", \"besouro\", \"escorpião\"]\n@show x\n@show rand(x);\n\nx = [\"aranha\", \"besouro\", \"escorpião\"]\nrand(x) = \"besouro\"\n\n\n\n\n\nDaisy vai armazenar o resultado de cada caçada de forma independete (nada de matrizes), ela usará um vetor de vetores.\n\n\n\n\n\n\nSintaxe: [] e push!\n\n\n\n\n\nVocê pode criar uma variável vazia e armazenar o que desejar com o comando push!, repare que existe um ! no nome, ou seja, ela altera a variável de entrada.\n\nx = []\n@show x\npush!(x, \"uma lesma\")\n@show x\npush!(x, \"outra lesma\")\n@show x;\n\nx = Any[]\nx = Any[\"uma lesma\"]\nx = Any[\"uma lesma\", \"outra lesma\"]\n\n\n\n\n\nJuntando todos os conhecimentos, Daisy além de criar a função que armazena o histórico de caçadas, ainda exibe de forma estruturada qual animal foi caçado, e em qual dia.\n\nfunction historico_caçadas(calendario_mensal, menu)\n    dias_da_semana = [\"Segunda\",\"Terça\", \"Quarta\",\n                \"Quinta\", \"Sexta\",\n                \"Sábado\", \"Domingo\"]\n\n    qtd_semanas, qtd_dias = size(calendario_mensal)\n    sim = one(eltype(calendario_mensal))\n\n    caçada_por_semana = map(1:qtd_semanas) do indice_semana\n        caçada_semanal = [] # vetor vazio\n\n        for indice_dia in 1:qtd_dias\n            if calendario_mensal[indice_semana, indice_dia] == sim\n                o_q_foi_caçado = rand(menu)\n                historico = ( dia = dias_da_semana[indice_dia],\n                              inseto = o_q_foi_caçado )\n                push!(caçada_semanal, historico)\n            end\n        end\n        caçada_semanal\n    end\n\n    return caçada_por_semana\nend\nmenu = [\"Besouro\", \"Aranha\", \"Escorpião\", \"Gafanhoto\"]\nagenda_fev = rand(Bool, 4, 7) # maneira compacta de obter 0 e 1\ncaçadas_fev = historico_caçadas(agenda_fev, menu)\n\nfor indice_semana = 1:4\n    println(\"Na semana $(indice_semana) Daisy pegou\")\n    for historico in caçadas_fev[indice_semana]\n        println(\"  - $(historico.dia) on $(historico.inseto)\")\n    end\nend\n\nNa semana 1 Daisy pegou\n  - Terça on Escorpião\n  - Quarta on Aranha\n  - Quinta on Escorpião\n  - Domingo on Gafanhoto\nNa semana 2 Daisy pegou\n  - Terça on Escorpião\n  - Quarta on Gafanhoto\n  - Sábado on Escorpião\nNa semana 3 Daisy pegou\n  - Segunda on Escorpião\n  - Quarta on Aranha\n  - Quinta on Besouro\n  - Sexta on Gafanhoto\nNa semana 4 Daisy pegou\n  - Segunda on Gafanhoto\n  - Quarta on Gafanhoto\n  - Sábado on Aranha\n  - Domingo on Aranha\n\n\n\nBom trabalho!\nParabéns! Você arrasou neste tutorial! Agora, você está pronto para criar suas próprias funções, manipular matrizes com facilidade e aplicar operações elemento a elemento. Com essas habilidades, você está preparado para mergulhar em novos desafios e aprender ainda mais nos próximos tutoriais."
  },
  {
    "objectID": "PART_2/00_going_travelling.html#mapas",
    "href": "PART_2/00_going_travelling.html#mapas",
    "title": "Parte 2",
    "section": "Mapas",
    "text": "Mapas\nDaisy é um viajante ávido e adora explorar novos lugares. Ela também é apaixonada por cartografia e cria mapas de suas viagens para documentar suas jornadas.\nNo entanto, ela geralmente acha difícil retratar com precisão o terreno e as características geográficas em seus mapas. Para melhorar a qualidade de seus mapas, ela pesquisou várias técnicas e recentemente se interessou por algoritmos de detecção de bordas.\nUsando detecção de bordas, ela espera ser capaz de identificar e destacar com mais precisão os limites de diferentes características do terreno, como montanhas, rios e vales, e tornar seus mapas mais informativos e visualmente atraentes."
  },
  {
    "objectID": "PART_2/00_going_travelling.html#paralelismo",
    "href": "PART_2/00_going_travelling.html#paralelismo",
    "title": "Parte 2",
    "section": "Paralelismo",
    "text": "Paralelismo\nBem-vindo a este capítulo emocionante! Aqui você terá a oportunidade de realizar uma operação incrível - Identificar Bordas em Imagens - e ainda utilizar o poder do paralelismo com diferentes ferramentas. Não se preocupe se ainda não tem uma imagem em mente, você pode escolher a que mais lhe agrada e usá-la como exemplo. Vamos lá!"
  },
  {
    "objectID": "PART_2/06_edge_detection.html",
    "href": "PART_2/06_edge_detection.html",
    "title": "6  Detecção de Bordas",
    "section": "",
    "text": "O objetivo de Daisy é aprimorar seus mapas detectando bordas, e seu algoritmo é muito simples, ela busca por mudanças abruptas na intensidade. Ela fez o desenho abaixo para ilustrar sua ideia, primeiro, ela converte a imagem do mapa em escala de cinza, compara pixels adjacentes, e diz que qualquer pixel acima de um valor limite (threshold) será considerado uma borda.\n\n\n\n\n\nDepois de detectar as bordas, Daisy pinta a imagem original com pontos vermelho para destacá-los. Dessa vez Daisy precisou instalar pacotes em Julia, ela precisou usar o Images.jl para carregar uma image de alta resolução do planeta todo.\n\n\n\n\n\n\nInstalar Pacotes\n\n\n\n\n\nA primeira maneira de instalar pacotes é com o pacote Pkg\n\nimport Pkg\nPkg.add(\"Images\")\n\nO segundo método é pelo terminal (também chamado REPL de Julia). Você deve apertar o ] no teclado. Isso vai alterar a palavra chave julia> para algo do tipo (@v1.9) pkg>. Em seguida, você pode dizer o comando de instalação.\n\n(@v1.9) pkg> add Images\n\nSerá esperado que você instale todos os pacotes futuramente apresentados.\n\n\n\n\n\n\n\n\n\nSintaxe: Canais de Cores\n\n\n\n\n\nPor padrão, o pacote Images.jl vai carregar imagens representadas em RGB(red, green, blue).\nExistem funções (felizmente) com os mesmos nomes que permitem encontrar os respectivos valores para cada pixel.\n\nsua_imagem = load(\".....\")\num_pixel = sua_imagem[3,5]\nr,g,b = red(um_pixel), green(um_pixel), blue(um_pixel)\n\nMas por exemplo, para encontrar todos os vermelhos de uma imagem, você deve usar o operador broadcast .\n\nsua_imagem = load(\".....\")\ncanal_vermelho = red.(sua_imagem)\n\n\n\n\n\nusing Images\nvermelho = RGBA(1.0,0,0.,1)\nthreshold = 0.02\n\nfunction detectar_bordas(imagem, threshold)\n    T = eltype(imagem) # tipo da matriz\n    altura, comprimento = size(imagem)\n    imagem_nova = zeros(T, altura, comprimento)\n\n    for y = 2:comprimento\n        for x = 2:altura\n            atual = imagem[x,y]\n            acima = imagem[x-1,y]\n            esquerda  = imagem[x,y-1]\n\n            if abs(atual-esquerda) ≥ threshold &&\n               abs(atual-acima) ≥ threshold\n                # se é uma borda, anota com '1'\n                imagem_nova[x,y] = one(T)\n            end\n        end\n    end\n    return imagem_nova\nend\n\nfunction pintar_bordas(imagem, mapa_de_bordas, vermelho)\n    imagem_com_bordas = deepcopy(imagem)\n\n    um = one(eltype(mapa_de_bordas))\n    onde_pintar = findall(mapa_de_bordas .== um)\n    imagem_com_bordas[onde_pintar] .= vermelho\n\n    return imagem_com_bordas\nend\n_original = Images.load(pwd()*\"/world.png\");\nimagem = (red.(_original) + green.(_original) + blue.(_original))/3\n\nbordas = detectar_bordas(imagem, threshold)\nimagem_com_bordas = pintar_bordas(_original, bordas, vermelho)\n\nimagem_com_bordas\n\nEsse código foi escrito com loops sem explorar nenhum paralelismo, por isso iremos chamar esse código de versão sequencial nas próximas seções."
  },
  {
    "objectID": "PART_2/07_at_threads.html",
    "href": "PART_2/07_at_threads.html",
    "title": "7  Threads.@threads",
    "section": "",
    "text": "Daisy quer tornar seu algoritmo de detecção de borda mais eficiente usando processamento paralelo com Threads. Sua opção mais simples em Julia é uma macro usada para a execução paralela threads.@Threads. Quando essa macro é usada, as iterações de loop são distribuídas igualmente entre as várias Threads disponíveis.\n\n\n\n\n\n\nNúmero de Threads\n\n\n\n\n\nO número de Threads usados para a execução paralela é determinado pela variável de ambiente JULIA_NUM_THREADS. Você pode verificar quantos threads você tem disponível chamando a função threads.nthreads()\n\nprintln(Threads.nthreads())\n\n\n\n\nPara deixar o código mais limpo, Daisy transformou a operação de detecção de bordas em uma função independente, assim ela pode focar apenas nos loops.\n\n\n\n\n\n\nkernel\n\n\n\nÉ tradição chamar a lógica central do algoritmo como kernel.\n\n\n\n\n\n\n\n\nSintaxe: @inline\n\n\n\n\n\nFazer uma chamada de função pode ser levemente mais demorado do que um programa contendo todos os comandos.\nSe você quer escrever em formato modular, com várias funções, mas o código final produzido pelo compialdor se torne um código extenso, com todas as funções encapsuladas em apenas um código, você pode dizer isso ao compilador com a macro @inline.\n\n\n\n\nfunction bordas_at_threads(imagem, threshold)\n    T = eltype(imagem) # tipo da matriz\n    altura, comprimento = size(imagem)\n    imagem_nova = zeros(T, altura, comprimento)\n\n    Threads.@threads for y = 2:comprimento\n        for x = 2:altura\n            kernel_bordas!(imagem, imagem_nova, T, threshold, x, y)\n        end\n    end\n    return imagem_nova\nend\n\n@inline function kernel_bordas!(imagem, imagem_nova, tipo_matrix, threshold, x, y)\n    atual = imagem[x,y]\n    acima    = imagem[x-1,y]\n    esquerda  = imagem[x,y-1]\n\n    if abs(atual-esquerda) ≥ threshold &&\n        abs(atual-acima) ≥ threshold\n        # se é uma borda, anota com '1'\n        imagem_nova[x,y] = one(tipo_matrix)\n    end\n    return nothing\nend\n\nbordas_paralelo_v1 = bordas_at_threads(imagem, threshold)\n# testar que código sequencial e paralelo produze o mesmo resultado\n@assert all(bordas .≈ bordas_paralelo_v1)\n\nA função all() é usada para verificar se todos os elementos nas duas imagens são (aproximadamente) iguais usando o operador ≈ (\\approx + TAB). Se o teste passar, significa que a implementação paralela produz a mesma saída que a implementação serial."
  },
  {
    "objectID": "PART_2/08_at_spawn.html",
    "href": "PART_2/08_at_spawn.html",
    "title": "8  Threads.@spawn",
    "section": "",
    "text": "Daisy está animada pois percebeu que existem loops encadeados (um for dentro de outro for) que potencialmente podem se beneficiar de mais paralelismo. Depois de algumas pesquisas, ela decidiu usar Threads.@spawn em seu código. Essa macro permite que cada iteração dos loops sejam executados de forma assíncrona.\nQuando @spawn é usado, uma novo Thread é criada enquanto o thread principal continua com sua execução sem esperar que as Threads terminem. Para fazer o programa principal aguardar pelas Thredas, Daisy precisou usar a macro @sync, para sincronizar as Threads.\nA mudança que Daisy precisou fazer em seu código foi pequena, trocando Threads.@threads por Threads.@spawn e @sync.\n\nfunction bordas_at_spawn(imagem, threshold)\n    T = eltype(imagem) # tipo da matriz\n    altura, comprimento = size(imagem)\n    imagem_nova = zeros(T, altura, comprimento)\n\n    @sync Threads.@spawn for y = 2:comprimento\n        for x = 2:altura\n            kernel_bordas!(imagem, imagem_nova, T, threshold, x, y)\n        end\n    end\n    return imagem_nova\nend\n\nbordas_paralelo_v2 = bordas_at_spawn(imagem, threshold)\n@assert all(bordas .≈ bordas_paralelo_v2)\n\nDaisy reparou que seu novo código é mais lento. Na próxima seção você descobrirá o motivo.\n\n\n\n\n\n\nPode conferir o tempo de execução com\n\n@time bordas_at_threads(imagem, threshold);\n@time bordas_at_spawn(imagem, threshold);"
  },
  {
    "objectID": "PART_2/09_spatial_divison.html",
    "href": "PART_2/09_spatial_divison.html",
    "title": "9  Divisão Espacial",
    "section": "",
    "text": "Daisy descobriu que o motivo para seu código com Threads.@spawn estar lento é que ela criou muitas Threads, ou seja, paras criar várias Threads demora algum tempo e o sistema operacional precisa anotar na memória que essa Threads existem. A solução anterior, com Threads.@threads foi mais eficiente, pois ela criou menos Threads, e cada Thread tinha uma carga de trabalho maior.\nDaisy decidiu que precisa de um controle ainda maior de seu código, ela quer ser mais específica e definir exatamente as regiões no qual cada Thread será executada. Ela quer uma divisão como representado abaixo, utilizando uma foto de suas viagens. Cada cor representa uma região da imagem controlada por uma Thread diferente, nesse exemplo, com 4 Threads.\n\n\n\n\n\nSeu primeiro passo é criar uma nova função que tenha mais controle dos loops, permitindo que Daisy diga exatamente qual região será trabalhada. Isso significa criar um outro for para gerenciar as regiões. Para ser simples, ela criou apenas duas regiões, e ao testar o tempo de execução, viu que é melhor que o código com Threads.@spawn.\n\nfunction bordas_duas_regiões(imagem_cinza, threshold)\n    T = eltype(imagem_cinza)\n    altura, comprimento = size(imagem_cinza)\n    nova_imagem = zeros(T, altura, comprimento)\n    duas_regiões = [2:(comprimento÷2),\n                    (comprimento÷2+1):comprimento]\n\n    @sync for região_y in duas_regiões\n        Threads.@spawn for y = região_y\n            for x = 2:altura\n                kernel_bordas!(imagem_cinza, nova_imagem, T, threshold, x, y)\n            end\n        end\n    end\n\n   return nova_imagem\nend\n_teste_ = bordas_duas_regiões(imagem, threshold)\n@assert all(bordas .≈ _teste_)\n\n\n\n\n\n\n\nRepare que Threads.@spawn e @sync precisaram ser colocados em posições diferentes.\n\n\n\nDaisy sabia que seu computador possuia uma CPU com 4 Cores e 8 Threads, mas ela não queria escrever um código para dividir 8 regiões. Após uma busca rápida na internet, Daisy achou a função Iterators.partition que resolve seu problema.\nPor último, Daisy descobre o tamaho de cada partição baseado na quantidade Threads disponiveis, e em seguida descobre os indices de inicio e fim de cada região.\n\nfunction bordas_varias_regiões(imagem, threshold)\n    T = eltype(imagem)\n    altura, comprimento = size(imagem)\n    imagem_nova = zeros(T, altura, comprimento)\n\n    tamanho_região = comprimento ÷ Threads.nthreads()\n    varias_regiões = collect(\n        Base.Iterators.partition(2:comprimento, tamanho_região)\n        )\n\n    @sync for região_y in varias_regiões\n        Threads.@spawn for y = região_y\n            for x = 2:altura\n                kernel_bordas!(imagem, imagem_nova, T, threshold, x, y)\n            end\n        end\n    end\n\n   return imagem_nova\nend\n\nbordas_paralelo_v3 = bordas_varias_regiões(imagem, threshold)\n@assert all(bordas .≈ bordas_paralelo_v3)"
  },
  {
    "objectID": "PART_2/10_threadsx.html",
    "href": "PART_2/10_threadsx.html",
    "title": "10  ThreadsX",
    "section": "",
    "text": "Daisy está ciente de que escrever código paralelo pode ser complicado e deseja garantir que sua implementação esteja correta. Para evitar bugs em potencial, ela buscou por pacote que possam a ajudar e acabou encontrando o pacote ThreadsX.jl, pois ele é muito fácil de usar, basta substituir funções Base, por exemplo, map por Threads.map.\nContudo, a função map executa uma função e retorna várias respostas. Da maneira como Daisy escreveu seu código, não existe nada a ser retornado, afinal, todas as mudanças já estão sendo escritas na matrix nova_imagem. Daisy então optou por usar a função ThreadsX.foreach, que existe justamente para esses cenários.\n\n\n\n\n\n\nSintaxe: foreach\n\n\n\n\n\nSe você gosta da sintaxe do map mas não precisa unir os resultados no final, use a função foreach.\n\nx = [1,2,3]\ny = map(x) do i\n    2*i\nend\n@show y;\n\nz = similar(x)\nforeach(x) do i\n    z[i] = 2*i\nend\n@show z;\n\ny = [2, 4, 6]\nz = [2, 4, 6]\n\n\n\n\n\n\nusing ThreadsX\nfunction bordas_ThreadsX(imagem, threshold)\n      T = eltype(imagem)\n    altura, comprimento = size(imagem)\n    imagem_nova = zeros(T, altura, comprimento)\n\n    tamanho_região = comprimento ÷ Threads.nthreads()\n    varias_regiões = collect( Base.Iterators.partition(2:comprimento, tamanho_região) )\n    ThreadsX.foreach(varias_regiões) do região_y\n        for y = região_y\n            for x = 2:altura\n                kernel_bordas!(imagem, imagem_nova, T, threshold, x, y)\n            end\n        end\n    end\n\n   return imagem_nova\nend\n\nbordas_paralelo_v4 = bordas_ThreadsX(imagem, threshold)\n@assert all(bordas .≈ bordas_paralelo_v4)"
  },
  {
    "objectID": "PART_2/11_parallel_stencil.html",
    "href": "PART_2/11_parallel_stencil.html",
    "title": "11  ParallelStencil",
    "section": "",
    "text": "Daisy teve um desenvolvimento tão incrível, que o lendário hacker, seu mestre Martin, decidiu levar Daisy a outro nível, Martin disse que processamento de imagens tem um grande aliado, Placas de Vídeo, e que Daisy deveria testar Cuda.\nNo entanto, os pais de Daisy não tem tanto dinheiro e se recusaram a comprar uma GPU. Os pais de Daisy acham que ela deveria estar caçando escorpiões, e quando ela ter seu próprio trabalho, ela mesmo poderá comprar sua RTX 4090.\nDaisy não desistiu. Ela procurou em toda parte por soluções, e finalmente se deparou com um pacote mágico chamado ParallelStencil.jl. Este pacote permitiu que ela fizesse seu código funcionar perfeitamente tanto em CPUs, quando em GPU, se disponível no computador.\nDaisy precisou ler a documentação do pacote, e descobriu que precisava modificar seu kernel para que funcionasse em paralelo, pois programação em placas de vídeo não tem loops com for ou while. O mesmo código (mesmo kernel) é executado em todas as regiões da image, e Daisy, a programadora, é responsável por descobrir qual o índice do loop imaginário.\n\n\n\n\n\n\nSe os parâmetros de entrada da função que está sendo executada em paralelo não forem complexos, o ParallelStencil.jl é capaz de identificar o tamanho da imagem e dividir as tarefas automaticamente. Por isso, foi necessário modificar a função novo_kernel para reduzir a quantidade de parâmetros de entrada necessários.\n\n\n\n\nusing ParallelStencil\n\n# Preciso iniciarlizar o pacote com o tipo de variavel padrão\n# que será utilizado, por exemplo, no comando\n# `ParallelStencil.@ones` a seguir\n@init_parallel_stencil(Threads, Float32, 2);\n\n# Se você já tem placa Nvidia configurada, pode usar essa linha\n# @init_parallel_stencil(CUDA, Float32, 2);\n\n@parallel_indices (x,y) function _novo_kernel!(imagem, imagem_nova, threshold)\n    T = eltype(imagem)\n    altura, comprimento = size(imagem)\n\n    if (    x >= 2  && x <= altura &&\n            y >= 2  && y <= comprimento )\n\n        atual = imagem[x,y]\n        acima    = imagem[x-1,y]\n        esquerda  = imagem[x,y-1]\n\n        if abs(atual-esquerda) ≥ threshold &&\n            abs(atual-acima) ≥ threshold\n            imagem_nova[x,y] = one(T)\n        end\n    end\n    return nothing\nend\n\nfunction bordas_ParStencil!(imagem, threshold)\n    imagem_nova = @zeros(size(imagem)...)\n    @parallel _novo_kernel!(imagem, imagem_nova, threshold)\n\n    return imagem_nova\nend\n\n\nbordas_paralelo_v5 = bordas_ParStencil!(imagem, threshold)\n@assert all(bordas .≈ bordas_paralelo_v5)"
  },
  {
    "objectID": "PART_2/12_benchmarks.html",
    "href": "PART_2/12_benchmarks.html",
    "title": "12  Benchmarks",
    "section": "",
    "text": "Depois de tanto trabalho, Daisy quer comparar todos os métodos e descobrir qual foi solução a mais rápida. Martin, seu mestre, disse que para fazer comparações de códigos que executam rápidamente (menos que 1 segundo) é recomendável utilizar um pacote especializado chamado BenchmarkTools.jl.\nA suricata prontamente utilizou o pacote para comparar todas as funções, e ainda calculou o speed up delas, para saber quantas vezes a função paralela é mais rápida que a solução sequencial.\n\n\n\n\n\n\nSpeedup é compara um valor antigo com o valor novo\n\\[\\text{Speedup} = \\frac{\\text{valor antigo}}{\\text{valor novo}}\\]\n\n\n\n\nusing BenchmarkTools\nimg = imagem\nt = threshold\n\ntempo_execução = zeros(6)\n\ntempo_execução[1] = @belapsed detectar_bordas($img, $t);\ntempo_execução[2] = @belapsed bordas_at_threads($img, $t);\ntempo_execução[3] = @belapsed bordas_at_spawn($img, $t);\ntempo_execução[4] = @belapsed bordas_varias_regiões($img, $t);\ntempo_execução[5] = @belapsed bordas_ThreadsX($img, $t);\ntempo_execução[6] = @belapsed bordas_ParStencil($img, $t);\n\n# primeiro item é a solução sequencial\nspeed_up = tempo_execução[1]./tempo_execução\n\n\nusing UnicodePlots\nnomes_funções = [\"Sequencial\",\n                \"@threads\",\n                \"@spawn\",\n                \"Regiões\",\n                \"ThreadsX\",\n                \"ParStencil\"\n            ]\nfig1 = barplot(nomes_funções, tempo_execução,\n    title=\"Tempo de execução [segundos]\")\nfig2 = barplot(nomes_funções, speedUp,\n    title=\"Speed up\")\n\n# savefig(fig1, \"tempo_execução.txt\")\n# savefig(fig2, \"speed_up.txt\")\n\nOs resultados de Daisy foram:\n\n                     Tempo de execução [segundos]\n              ┌                                        ┐\n   Sequencial ┤■■■■■ 0.0557669\n     @threads ┤■■■■■■■■■ 0.111283\n       @spawn ┤■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■ 0.352736\n      Regiões ┤■■■■■■■■■ 0.10945\n     ThreadsX ┤■■■■■■■■■■ 0.118113\n   ParStencil ┤■■■ 0.0325353\n              └                                        ┘\n                               Speed up\n              ┌                                        ┐\n   Sequencial ┤■■■■■■■■■■■■■■■■■■ 1\n     @threads ┤■■■■■■■■■ 0.501127\n       @spawn ┤■■■ 0.158098\n      Regiões ┤■■■■■■■■■ 0.509519\n     ThreadsX ┤■■■■■■■■■ 0.47215\n   ParStencil ┤■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■ 1.71404\n              └                                        ┘\n\nDaisy ficou surpresa que o código paralelo foi, em geral, mais lento que o sequencial, uma vez que ela sempre escutou o contrário. Martin então explica que programação paralela tem um custo inicial que não é pequeno.\nComo a imagem do seu mapa mundial não tinha gigabytes de tamanho, e a complexidade do algoritmo também foi modesta, a sobrecarga de criar e gerenciar as Threads em paralelo demorou mais tempo que executar 2 loops.\nSomente o seu último código, o bordas_ParStencil, foi o mais rápido, porque ele foi inteligente o suficiente para minimzar a distribuição de tarefas, fazendo valer a pena o paralelismo.\n\nParabéns\nNão se preocupe em procurar tempos de execução menores ainda, o objetivo desse capítulo foi te dar condições de usar Multithreading em seus códigos, que se resume em colocar alguns comandos (@threads, @spawn) de maneira engenhosa, ou usar algum pacote que faça isso para você."
  },
  {
    "objectID": "PART_3/00_going_for_work.html#ao-trabalho",
    "href": "PART_3/00_going_for_work.html#ao-trabalho",
    "title": "Parte 3",
    "section": "Ao Trabalho",
    "text": "Ao Trabalho\nDaisy está determinada a guardar dinheiro para suas futuras viagens - e quem sabe uma placa de vídeo. Para tal, ela decidiu trabalhar para sua gangue. Sua idéia foi oferecer serviços de babá para recém-nascidos. Ela adora passar um tempo com crianças e acredita que seria uma ótima maneira de ganhar dinheiro enquanto relaxa sob o sol. Contudo, isso não será o suficiente…."
  },
  {
    "objectID": "PART_3/00_going_for_work.html#processos-distribuídos",
    "href": "PART_3/00_going_for_work.html#processos-distribuídos",
    "title": "Parte 3",
    "section": "Processos Distribuídos",
    "text": "Processos Distribuídos\nEste é o capítulo que trará ferramentas mais ponderosas, e ao mesmo tempo, trará problemas mais complicados, pois os processos paralelos precisam se comunicar. Em Julia o pacote Distributed.jl é a solução para muitos dos problemas que você poderá encontrar."
  },
  {
    "objectID": "PART_3/13_pmap.html",
    "href": "PART_3/13_pmap.html",
    "title": "13  pmap",
    "section": "",
    "text": "Cuidar dos suricates recém-nascidos foi super fácil para Daisy. Ela os deixava sair para brincar ou relaxar sob o sol. Mais tarde, quando eles voltaram, ela anotava quanto tempo cada suricate ficou brincando.\nDiferente dos outros programas que ela escreveu, dessa vez cada suricate esta em um local diferente, então seus códigos precisarão ser executados em computadores diferentes, ou seja, sem ajuda de multithreading. Martin diz a Daisy que Julia permite executar Julia em computadores diferentes nativamente (ou seja, não preicsa de outros programas), mas requer atenção aos detalhes. O recomendável é usar o pacote Distributed.jl, pois oferece as funções úteis para a grande maioria dos problemas.\nPara simplificar seus relatórios, Daisy atribuiu a cada suricate um número, começando com 2 (já que ela é o número 1). Ela só permitiu que os recém-nascidos brincassem em quatro áreas seguras vigiadas por 4 workers.\n\n\n\n\n\nDaisy deseja um código simples, cada worker vai informar quanto tempo cada suricate filhote ficou brincando no sol. A função ideal para fazer isso sem nenhum paralelismo é map, e Daisy encontrou sua versão equivalente em Distributed.jl, é a pmap.\n\n\n\n\n\n\nSintaxe: Distributed\n\n\n\n\n\nEsse pacote é responsável por criar novas instâncias de Julia em máquinas remotas. Ficaremos com o caso mais simples, e usaremos apenas os vários Cores do seu processador para emular outros computadores.\n\nusing Distributed\naddprocs(3) # 'criou'/'conectou' com 3 máquinas\n...\nrmprocs() # 'apaga'/'desliga' todas as máquinas\n\n\n\n\n\n\n\n\n\n\nSempre que você encontrar o comando rmprocs em algum exemplo, isso significa que é necessário encerrar a sessão atual de Julia e iniciar uma nova. Isso garante que não haja confusão com a quantidade de processos ativos, e garante que futuros tutoriais funcionem corretamente.\n\n\n\nPara que Daisy só escreva seu código em uma máquina, e copie ele em todas as outras, foi necessário o comando @everywhere. A primeira tentativa de Daisy gerou esse código, e que já funciona corretamente.\n\nusing Distributed\naddprocs(4) # 4 playgrounds\n\n@everywhere function brincar_no_sol(suricate)\n    # Cada suricate passa um tempo aleatório no sol\n    tempo = round( 2rand(), digits=2) # tempo brincando\n    println(\"suricate '$(suricate)' brincou $(tempo) horas\")\n    return tempo\nend\n\nsuricates = [2,3,4,5,6] # os 'nomes' dos suricate são seus 'ids'\nrelatorio = pmap(suricates) do suricate\n    brincar_no_sol(suricate)\nend;\n\n      From worker 2:    suricate '4' brincou 0.41 horas\n      From worker 3:    suricate '2' brincou 0.5 horas\n      From worker 4:    suricate '3' brincou 1.61 horas\n      From worker 5:    suricate '5' brincou 1.41 horas\n      From worker 3:    suricate '6' brincou 1.86 horas"
  },
  {
    "objectID": "PART_3/14_at_spawnat.html",
    "href": "PART_3/14_at_spawnat.html",
    "title": "14  @spawnat",
    "section": "",
    "text": "Depois de implementar seu código usando o paralelismo distribuído, Daisy percebeu que cada suricatinho tinha uma preferência, cada um gostava mais de uma certa região, e Daisy queria respeitar essa preferência. Para tornar o código mais legível, cada suricate foi representado como uma Tupla Nomeada.\n\nsuricates = [(nome=2,região=2),\n            (nome=3, região=2),\n            (nome=4, região=3),\n            (nome=5, região=4),\n            (nome=6, região=4)\n            ]\n\nMas como enviar cada suricate para cada região de preferencia? Para conseguir isso, Daisy voltou a documentação do pacote Distributed.jl, e descobriu a macro @spawnat que faz justamente o que ela buscava.\n\n\n\n\n\n\nSintaxe: @spawnat\n\n\n\n\n\nVocê deve especificar qual o id da máquina que irá executar sua função.\n\nresposta = Distributed.@spawnat id_maquina sua_função(....)\n\nCaso não seja importante o id, poderia usar o comando :any\n\nresposta = Distributed.@spawnat :any sua_função(....)\n\n\n\n\nDiferentemente de multithreading, quando ela executou o código, a resposta não foi o que ela desejava, como foi o caso do pmap, agora com o @spawnat a variável de resposta foi do tipo Future, que servia apenas como ‘nota fiscal’/‘ticket’. Era uma variável que garantia que a tarefa foi enviada ao processo, mas não retornava o valor. Para realmente obter os dados, Daisy precisava usar um comando especial, o fetch.\n\nrelatorio = map(suricates) do s\n    @spawnat s.região brincar_no_sol(s.nome)\nend;\n# Para recuperar a resposta de apenas 1 elemento\n# `fetch(relatorio[1])`\n\ndados_relatorio = fetch.(relatorio)"
  },
  {
    "objectID": "PART_3/15_shared_arrays.html#parte_local",
    "href": "PART_3/15_shared_arrays.html#parte_local",
    "title": "15  SharedArrays",
    "section": "15.1 parte_local",
    "text": "15.1 parte_local\nDaisy não trabalhava sozinha, ela era responsável por uma pequena região, de uma grande área, compartilhada com outros suricates. Sua nova chefe, a suricata Jessie, controlava quais regiões cada suricate é autorizado a trabalhar, e cada região eram chamada de parte_local, pois cada suricate só trabalha na sua parte.\nDaisy já tinha fama de programadora, assim foi convocada por Jessie a escrever um código para verificar que cada suricate esta nos seus limites.\nNessa situação, Daisy precisou usar outro pacote, o SharedArrays.jl, pois ela conseguiria representar a área total de excavação como uma variável compartilhada, no qual cada suricate excavador pode ter acesso.\n\n@everywhere using SharedArrays\nterreno = SharedMatrix{Int}((4,16), pids = workers())\n\n@everywhere function ver_parte_local!(terreno)\n    parte_local = localindices(terreno)\n    println(\"suricate '$(myid())' trabalha em '$(parte_local)'\")\n    terreno[parte_local] .= myid()\nend\nfor w in workers()\n    Distributed.@spawnat w ver_parte_local!(terreno)\nend\nterreno\n\n\n\n\n\n\n\nSintaxe: localindices\n\n\n\n\n\nMatrizes em Julia armazenam os valores de forma continua na memória como na figura abaixo. \nlocalindices retornou os indices implicitos de cada valor, e não as linhas e colunas.\n\n\n\n\n\n\n\n\n\nSintaxe: myid\n\n\n\n\n\nTodos os processos podem acessar e editar todos os valores da variável terreno porque SharedArrays gerencia a memória para que você não tenha que escrever um código para isso. Nesse exemplo, cada processo apenas anotou seu id, obtido com a função myid.\n\n\n\nComo a área possuia 16 locais de excavação e 4 trabalhadores, a distribuição de tarefas era direta, com cada suricate foi designado para 4 locais."
  },
  {
    "objectID": "PART_3/15_shared_arrays.html#túneis",
    "href": "PART_3/15_shared_arrays.html#túneis",
    "title": "15  SharedArrays",
    "section": "15.2 Túneis",
    "text": "15.2 Túneis\nAgora que cada suricate conhece seus limites, eles podem começar a escavação dos seus túneis. No entanto os códigos de Daisy tem um requisito muito forte: a representação do túnel em seus códigos não pode ter lacunas entre as camadas, ou seja, cada camada deve ser conectada à anterior.\n\nDaisy chegou numa solução simples, baseada na sua experiência em anotar dias de que poderia sair de casa, ela vai criar uma matriz de zeros representando o terreno, e as áreas escavadas, ela indicou usando 1. Por enquanto Daisy só tem um protótipo, ele funciona apenas para testar que a construção do túnel esta funcionando como deveria no desenho.\n\n\n\n\n\n\nSintaxe: findfirst\n\n\n\n\n\nPara encontrar o 1 na camada superior, Daisy só precisar a posição do único 1 que deverá estar armazenado, para isso Daisy usou a função findfirst\n\n# encontra o primeiro valor '4'\nx = [4,3,4,4,6]\n@show findfirst(x .== 4)\n\ny = [false, false, true, false, true]\n@show findfirst(y);\n\nfindfirst(x .== 4) = 1\nfindfirst(y) = 3\n\n\n\n\n\n\nfunction escavar_tunel!(terreno)\n    linhas, colunas = size(terreno)\n\n    # primeira linha é a linha do solo\n    ponto_partida = rand(1:colunas)\n    terreno[1, ponto_partida] = one(eltype(terreno))\n\n    for i in 2:linhas\n        ultima_posicao = findfirst( terreno[i-1,:] )\n\n        esquerda = ultima_posicao - 1\n        meio = ultima_posicao\n        direita = ultima_posicao + 1\n\n        if esquerda < 1\n            possiveis_posições = [direita, meio]\n        elseif direita > colunas\n            possiveis_posições = [meio, esquerda]\n        else\n            possiveis_posições = [esquerda, meio, direita]\n        end\n\n        local_para_escavar = rand(possiveis_posições)\n        terreno[i, local_para_escavar] = one(eltype(terreno))\n    end\nend\n\nterreno = zeros(Bool, 10, 6)\nescavar_tunel!(terreno)\n\n# Somente para visualização no terminal\nusing SparseArrays\nsparse(terreno)\n\n10×6 SparseMatrixCSC{Bool, Int64} with 10 stored entries:\n ⋅  ⋅  ⋅  ⋅  1  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  ⋅  1  ⋅"
  },
  {
    "objectID": "PART_3/15_shared_arrays.html#terreno-rochoso",
    "href": "PART_3/15_shared_arrays.html#terreno-rochoso",
    "title": "15  SharedArrays",
    "section": "15.3 Terreno Rochoso",
    "text": "15.3 Terreno Rochoso\nEm um certo dia, o local da escavação era mais rochoso que o esperado, e ao mesmo tempo, um dos suricates ficou doente e não podia trabalhar, resultando em uma distribuição desigual de tarefas.\nDaisy foi chamada as pressas, seu protótipo precisa funcionar, e ainda levar em conta a zona de trabalho (parte_local) de cada suricate. Daisy sabia que usar os indices implicitos do SharedArrays não seria útil, a solução foi cada suricate informar carregar consigo em um papel qual sua região de trabalho, ou seja, a parte_local será uma variável de entrada.\n\n@everywhere function escavar_tunel!(terreno, parte_local)\n    qtd_camadas = size(terreno, 1)\n\n    # primeira linha é a linha do solo\n    tamanho_região = length(parte_local)\n    ponto_partida = parte_local[rand(1:tamanho_região)]\n    terreno[1, ponto_partida] = one(eltype(terreno))\n\n    for i in 2:qtd_camadas\n        ulitma_camada = terreno[i-1, parte_local]\n        idx_local = findfirst(ulitma_camada)\n        ultima_posicao = parte_local[idx_local]\n\n        esquerda = ultima_posicao - 1\n        meio = ultima_posicao\n        direita = ultima_posicao + 1\n\n        if esquerda < parte_local[1]\n            possiveis_posições = [direita, meio]\n        elseif direita > parte_local[end]\n            possiveis_posições = [meio, esquerda]\n        else\n            possiveis_posições = [esquerda, meio, direita]\n        end\n\n        local_para_escavar = rand(possiveis_posições)\n        terreno[i, local_para_escavar] = one(eltype(terreno))\n    end\n\n   return nothing\nend\n\n\n# suricate `4` ficou doente\n# então suricate `2` precisou compensar\nrochoso = SharedMatrix{Bool}((16,8+3+6), pids = [2,3,5])\nescavadores = [(nome=2, parte_local=1:8),\n               (nome=3, parte_local=9:11),\n               (nome=5, parte_local=12:17)\n              ]\nfor s in escavadores\n    @spawnat s.nome escavar_tunel!(rochoso, s.parte_local)\nend\n\nsparse(rochoso)\nrmprocs()"
  },
  {
    "objectID": "PART_3/16_distributed_arrays.html#novos-índices",
    "href": "PART_3/16_distributed_arrays.html#novos-índices",
    "title": "16  DistributedArray",
    "section": "16.1 Novos índices",
    "text": "16.1 Novos índices\nFuli também tem experiência com programação, e informa Daisy que seus códigos apesar de bem intencionados, nunca funcionariam na linha de produção, pois SharedArrays.jl é uma solução para emular processos distribuidos, mas exige que os dados sejam compartilhados, ou seja, suas matrizes precisam estar no mesmo computador.\nCaso Daisy queira rodar seus códigos em paralelo de verdade, ela precisa usar o pacote DistributedArrays.jl. Esse pacote facilita a distribuição dos indices de cada trabalhador, mas precisa de um pouco de atenção para acessar os dados corretamente.\n\nDaisy ficou confusa, mas Fuli lhe deu alguns exemplos básicos. Fuli explica que é necessário criar variáveis distribuidas, do mesmo jeito que Daisy criou uma matriz preenchida com zeros, usando a função zeros, o pacote DistributedArrays.jl disponibiliza alguns comandos semelhantes, mas com um d adicional, tal como dzeros, dones.\n\nusing Distributed\naddprocs(2)\n\n@everywhere using DistributedArrays\nexemplo = dzeros(Int64, 3, 6)\n\n@everywhere function ver_indices_globais(exemplo)\n\n    Δx, Δy = DistributedArrays.localindices(exemplo)\n    println(\"índices Globais: Δx = $(Δx), Δy = $(Δy)\")\nend\n\nfor w in workers()\n    @spawnat w ver_indices_globais(exemplo)\nend\nsleep(1) # para dar tempo da mensagem aparecer\n\n      From worker 2:    índices Globais: Δx = 1:3, Δy = 1:3\n      From worker 3:    índices Globais: Δx = 1:3, Δy = 4:6\n\n\n\n\n\n\n\n\nSintaxe: distribute\n\n\n\n\n\nCaso você deseje criar uma matriz no localmente, e depois distribui-lá, é só usar o comando disitrubte(matriz)\n\n# encontra o primeiro valor '4'\nA = [1 0 0; 2 0 0; 3 0 0]\ndA = distribute(A)\n\n3×3 DArray{Int64, 2, Matrix{Int64}}:\n 1  0  0\n 2  0  0\n 3  0  0\n\n\n\n\n\nUma vez que Daisy conhece os índices globais, os índices locais são iguais aos comprimento de cada intervalo. Fuli alerta Daisy, para escrever em matrizes distribuidas, só podem ser utilizados indices locais, e além disso, com uma palavra chave especial, localpart, então Daisy deveria ter cuidado, e não confundir o parte_local que ela já havia criado anteriormente - talvez uma mudança de nome de variáveis seriam bem vindas, Daisy precisaria falar com seu mestre.\n\n@everywhere function escrever_indice_local!(exemplo)\n\n    Δx, Δy = DistributedArrays.localindices(exemplo)\n    indice_local_x = 1:length(Δx)\n    indice_local_y = 1:length(Δy)\n\n    for x in indice_local_x, y in indice_local_y\n        localpart(exemplo)[x, y] = myid()\n    end\nend\nexemplo = dzeros(Int64, 3, 6)\nfor w in workers()\n    @spawnat w escrever_indice_local!(exemplo)\nend\ndisplay(exemplo);\nrmprocs();\n\n3×6 DArray{Int64, 2, Matrix{Int64}}:\n 2  2  2  3  3  3\n 2  2  2  3  3  3\n 2  2  2  3  3  3"
  },
  {
    "objectID": "PART_3/16_distributed_arrays.html#novos-tunéis",
    "href": "PART_3/16_distributed_arrays.html#novos-tunéis",
    "title": "16  DistributedArray",
    "section": "16.2 Novos tunéis",
    "text": "16.2 Novos tunéis\nDaisy fez muitos erros, mas finalmente conseguiu, ela adpatou seu código antigo para utilizar o pacote DistributedArrays.jl. Depois de tantos bugs, Daisy chegou a conclusão que é melhor fazer tratamentos de erro, já que quando bugs acontecem em processos remotos, eles não são redirecionados ao processo central, logo, não existem mensagens de erro na tela.\n\n\n\n\n\n\nSintaxe: try\n\n\n\n\n\nUm bloco try-catch funciona como esperado de outras linguagens de programação, sua utilização básica consiste em apenas colocar o seu código dentro do bloco try.\n\ntry\n    sqrt(-1)\ncatch\n    println(\"Não é possível fazer sqrt(-1)\")\n    println(\"Tente sqrt(Complex(-1))\")\nend\n\nNão é possível fazer sqrt(-1)\nTente sqrt(Complex(-1))\n\n\n\n\n\n\nusing Distributed\naddprocs(3)\n@everywhere using DistributedArrays\n\n@everywhere function d_escavar_tunel!(terreno)\n    try\n        Δx, Δy = DistributedArrays.localindices(terreno)\n\n        qtd_camadas = length(Δx)\n        tamanho_região = length(Δy)\n\n        # primeira linha é a linha do solo\n        ponto_partida = rand(1:tamanho_região)\n\n        # '1' == escavar a posição\n        escavar = one(eltype(terreno))\n        localpart(terreno)[1, ponto_partida] = escavar\n\n        for i in 2:qtd_camadas\n            ulitma_camada = localpart(terreno)[i-1, :]\n\n            # garante que o código funcione para outros\n            # tipos de matrizes, além dos tipos `true`/`false`\n            ultima_posicao = findfirst( ulitma_camada .== escavar )\n\n            esquerda = ultima_posicao - 1\n            meio = ultima_posicao\n            direita = ultima_posicao + 1\n\n            if esquerda < 1\n                possiveis_posições = [direita, meio]\n            elseif direita > tamanho_região\n                possiveis_posições = [meio, esquerda]\n            else\n                possiveis_posições = [esquerda, meio, direita]\n            end\n\n            aonde_escavar = rand(possiveis_posições)\n            localpart(terreno)[i, aonde_escavar] = escavar\n        end\n    catch\n        println(\"Aconteceu um Erro.\")\n    end\n\n   return nothing\nend\n\nA construção da matriz distribuída também requer um cuidado adicional, pois é possível controlar quais suricates vão participar da construção do túnel, e em quantas partes cada dimensão da matriz será particionada.\n\n## Preciso passar uma tupla com as dimensões da matriz\ndimensões_terreno = (10, 6)\n\n## Um vetor com os processos que farão o trabalho\nescavadores = workers()\n\n# Cada componente do vetor, corresponde a qtd\n# de particições em cada dimensão. Por exemplo\n# ['1', 2] = eixo 1 não tem divisão\n# [1, '3'] = eixo 2 é divido em 3 partes\ndivisões = [1, 3]\n\n# não tem função que cria matriz booleana,\n# então preciso usar a função `dfill`\nterreno = dfill(false, dimensões_terreno, escavadores, divisões)\n\nfor w in workers()\n    @spawnat w d_escavar_tunel!(terreno)\nend\n\nusing SparseArrays\nsparse(terreno)\n\nrmprocs()"
  },
  {
    "objectID": "PART_3/17_pipeline.html#remotechannel",
    "href": "PART_3/17_pipeline.html#remotechannel",
    "title": "17  pipeline",
    "section": "17.1 RemoteChannel",
    "text": "17.1 RemoteChannel\nA suricata enfrenta um novo desafio de programação, agora a comunicação entre os processos é crucial. Ela procura a ajuda de Martin e descobre que todos os pacotes anteriores que ela utilizou, já possuiam algum nível de comunicação nos bastidores, mas agora ela precisa aprender esses truques por si mesma. Em Julia, a comunicação entre processos é feita com Channel, e para processos em computadores diferentes, com RemoteChannel.\n\n\n\n\n\n\nSintaxe: remotechannels\n\n\n\n\n\nUm RemoteChannel é um canal de comunicação entre processos que funciona com uma fila, logo, a primeira mensagem a ser colocada, é a primeira ser retirada (FIFO). Todos os processos podem escrever dados com pu!, e efetuar leitura com take!.\n\nusing Distributed\naddprocs(3)\n\n# todos os processos podem\n# ler e escrever até 4 mensagens\nRC = RemoteChannel(() -> Channel(4))\n\n# uso o comando `put!`\n## líder\nput!(RC, \"mensagem 1\")\n\n## trabalhadores\n@spawnat 2 put!(RC, \"mensagem 2\")\n@spawnat 3 put!(RC, \"mensagem 3\")\n@spawnat 4 put!(RC, \"mensagem 4\")\n\n\n# ler dados é com o `take!`\n@everywhere function ler_dado(RC)\n    mensagem = take!(RC)\n    println(mensagem)\nend\n\n# cada processo para faz uma leitura\n## líder\nler_dado(RC);\n\n## trabalhadores\n@spawnat 2 ler_dado(RC);\n@spawnat 3 ler_dado(RC);\n@spawnat 4 ler_dado(RC);\n\nrmprocs()\n\nAtenção Se você pede a leitura dos dados, a execução do programa fica travada esperando pelos dados. Então no exemplo, após a leitura das 4 mensagens, se fosse requisitado uma nova leitura, o código ficaria travado indefinitivamente.\n\n(...)\n@spawnat 3 ler_dado(RC);\n@spawnat 4 ler_dado(RC);\n\n# A fila esta vazia, portanto uma nova leitura\n# iria ficar aguardando infinitamente algum dado\nler_dado(RC)\n\n\n\n\nMartin alerta Daisy que suas funções precisam virar serviços, ela precisará criar funções que rodam eternamente, apenas esperando por requisições, só assim, ela pipelines funcionarem. A solução mais simples é criar funções dentro de bloco while true ... end.\n\n\n\n\n\n\nSintaxe: Serviços Remotos\n\n\n\n\n\nVocê vai aproveitar do fato que take! fica aguardando dados por tempo indeterminado, mas não no nó líder (processo 1), mas apenas nos trabalhadores remotos, já que assim não atrapalha a execução do seu programa.\n\nusing Distributed\naddprocs(2)\n\n@everywhere function ler_dado(RC)\n    while true\n        mensagem = take!(RC)\n        sleep(1)\n        println(mensagem)\n    end\n    return nothing\nend\n\n# canal aceita apenas 4 dado por vez\nRC = RemoteChannel(() -> Channel(4))\n\n# apenas o processo '2' ficará\n# travado esperando por dados\n@spawnat 2 ler_dado(RC)\n\nput!(RC, \"mensagem 1\");\nput!(RC, \"mensagem 2\");\n@spawnat 3 put!(RC, \"mensagem 3\");\n@spawnat 3 put!(RC, \"mensagem 4\");\n\nrmprocs()\n\nTask (done) @0x00007f3d6c4892d0\n\n\n\n\n\nDaisy atualizou seu desenho para ser mais técnica, e incluir o que aprendeu."
  },
  {
    "objectID": "PART_3/17_pipeline.html#nova-escavação",
    "href": "PART_3/17_pipeline.html#nova-escavação",
    "title": "17  pipeline",
    "section": "17.2 Nova Escavação",
    "text": "17.2 Nova Escavação\nCriar túneis acontecerá em 2 estágios, logo, Daisy pegou os códigos antigos, e os adaptou para o novo desafio. Dessa vez ela reparou que poderia ser muito mais eficiente. Se no lugar ter uma matriz com 0 e 1, ela poderia ter apenas um vetor contendo a posição exata da escavação (apenas a posição do indice aonde ficaria registrado o valor 1).\nAbaixo, Daisy escreveu seu código para as primeiras etapas.\n\nusing Distributed\naddprocs(3)\n\n@everywhere function etapa_1(qtd_camadas, tamanho_região, RC_entrada, RC_saida)\n    while true\n        ponto_partida = take!(RC_entrada)\n        println(\"[Começou] Primeira Etapa\")\n\n        pontos_escavação = [ponto_partida]\n        escavar!(pontos_escavação, qtd_camadas, tamanho_região)\n\n        put!(RC_saida, pontos_escavação)\n        println(\"[Terminado] Primeira Etapa\")\n    end\nend\n\n@everywhere function etapa_2(qtd_camadas, tamanho_região, RC_entrada, RC_saida)\n    while true\n        # recebe as etapas anteriores\n        pontos_escavação = take!(RC_entrada)\n        println(\"[Começou] Segundo Etapa\")\n\n        escavar!(pontos_escavação, qtd_camadas, tamanho_região)\n\n        put!(RC_saida, pontos_escavação)\n        println(\"[Terminado] Segundo Etapa\")\n    end\nend\n\n@everywhere @inline function escavar!(pontos_escavação, qtd_camadas, tamanho_região)\n\n    for i in 2:qtd_camadas\n        ultima_posicao = pontos_escavação[end]\n\n        esquerda = ultima_posicao - 1\n        meio = ultima_posicao\n        direita = ultima_posicao + 1\n\n        if esquerda < 1\n            possiveis_posições = [direita, meio]\n        elseif direita > tamanho_região\n            possiveis_posições = [meio, esquerda]\n        else\n            possiveis_posições = [esquerda, meio, direita]\n        end\n        aonde_escavar = rand(possiveis_posições)\n        push!(pontos_escavação, aonde_escavar)\n    end\n    return nothing\nend"
  },
  {
    "objectID": "PART_3/17_pipeline.html#mapa-de-profundidade",
    "href": "PART_3/17_pipeline.html#mapa-de-profundidade",
    "title": "17  pipeline",
    "section": "17.3 Mapa de Profundidade",
    "text": "17.3 Mapa de Profundidade\nPara a terceira fase, Fuli precisava de um mapa agradável aos olhos, já que ele iria apresentar os resultados em formato de relatório aos investidores - e suricates investidores também tem medo de ver números brutos.\nBaseada em sua experiência com detecção de bordas, Daisy decidiu criar um mapa pintado de vermelho aonde foi escavado, e quanto mais profundo, mais escuro ficam as cores.\n\n@everywhere using Images\n@everywhere function etapa_3(qtd_camadas, tamanho_região, RC_entrada, RC_saida)\n    while true\n        # recebe o túnel completo\n        pontos_escavação = take!(RC_entrada)\n        println(\"[Começou] Terceira Etapa\")\n\n        # mais profundo == mais escuro\n        alphas = range(1.0, 0.25, length = 2qtd_camadas)\n        mapa = [RGBA(1.0, 1.0, 1.0, 1.0)\n            for i ∈ 1:2qtd_camadas, j ∈ 1:tamanho_região]\n\n        for i in eachindex(pontos_escavação)\n            # mostra a divisão entre etapas\n            # com uma cor diferente\n            if i == qtd_camadas\n                mapa[i, :] .= RGBA(1.0, 1.0, 1.0, 0.7)\n            end\n\n            mapa[i, pontos_escavação[i]] = RGBA(1.0, 0.0, 0.0, alphas[i])\n        end\n\n        put!(RC_saida, mapa)\n        println(\"[Terminado] Terceira Etapa\")\n    end\nend"
  },
  {
    "objectID": "PART_3/17_pipeline.html#fuli",
    "href": "PART_3/17_pipeline.html#fuli",
    "title": "17  pipeline",
    "section": "17.4 Fuli",
    "text": "17.4 Fuli\nDaisy pegou seu último desenho e o traduziu para códigos. Ela precisava de 4 canais remotos. Uma vez criados, ela notificou cada suricate com as dimensões do projeto, para que eles ficassem aguardando instruções.\n\nRC_1 = RemoteChannel(() -> Channel(1))\nRC_2 = RemoteChannel(() -> Channel(1))\nRC_3 = RemoteChannel(() -> Channel(1))\nRC_4 = RemoteChannel(() -> Channel(1))\n\nqtd_camadas, comprimento = 25, 30\n@spawnat 2 etapa_1(qtd_camadas, comprimento, RC_1, RC_2)\n@spawnat 3 etapa_2(qtd_camadas, comprimento, RC_2, RC_3)\n@spawnat 4 etapa_3(qtd_camadas, comprimento, RC_3, RC_4)\n\nCom tudo preparado, Fuli apareceu, e disse que o ponto de partida de escavação seria bem no centro do terreno.\n\npartida_da_escavação = 15\nput!(RC_1, partida_da_escavação)\n\nNo final do dia, Fuli estava de volta, agora ele queria o mapa dos resultados, antes que todos os suricates fossem dispensados para casa.\n\nmapa_tunel = take!(RC_4)\nsave(\"tunnel_map.png\", mapa_tunel)\n\nrmprocs()\n\nAbaixo, segue um exemplo de túnel escavado da parte superior até a inferior, e a linha cinza indica a transição de um suricate para outro."
  },
  {
    "objectID": "PART_3/18_spmd.html#primeiro-teste",
    "href": "PART_3/18_spmd.html#primeiro-teste",
    "title": "18  SPMD",
    "section": "18.1 Primeiro Teste",
    "text": "18.1 Primeiro Teste\nEla começou seus testes, começando com uma simulação. Ela iria supor que uma cobra foi avistada por uma Sentinela Real, e então precisaria notificar todos as outras Sentinelas, compartilhando informações sobre a posição da cobra em uma matriz.\n\n\n\n\n\n\nSintaxe: bcast\n\n\n\n\n\nEm SPMD, esse conceito de transmitir a todos os processos algum valor, é conhecido como broadcast, e no pacote DistributedArrays.jl, é necessário usar o comando bcast.\n\n\n\n\nusing Distributed, DistributedArrays\naddprocs(3)\n\n@everywhere using DistributedArrays\n@everywhere using DistributedArrays.SPMD\n\n@everywhere function spmd_teste_bcast()\n    if myid() == 2\n        # matriz com dados da cobra\n        A = [i*(1.0 + im*2.0) for i = 1:3]\n    else\n        # Não se esqueça de definir a variável `A`, mesmo que\n        # você não a usa antes do `bcast` os nenhum processos\n        A = nothing\n    end\n    print(\"Antes bcast, '$(myid())' tem A = $A\\n\")\n\n     ## Processo `2` envia 'A' para toda a rede\n     ## A rede recebe 'novoA'\n    novoA = bcast(A, 2)\n\n    # É necessário parar e esperar que todos\n    # os processos tenham o mesmo dado\n    barrier(;pids=[2,3,4])\n\n    print(\"Depois bcast, '$(myid())' tem A = $novoA\\n\")\n    nothing\nend\nspmd(spmd_teste_bcast; pids=workers())"
  },
  {
    "objectID": "PART_3/18_spmd.html#segundo-teste",
    "href": "PART_3/18_spmd.html#segundo-teste",
    "title": "18  SPMD",
    "section": "18.2 Segundo Teste",
    "text": "18.2 Segundo Teste\nDaisy consegue comunicar a todos a respeito da ameaça, mas como que ela vai saber quem irá ajudar a combate-lá? Para isso, ela precisou dos comandos sendto e recvfrom - ‘enviar para’ e ‘receber de’ em uma tradução livre. Seu novo código é uma modificação do anterior, para ter certeza que todos os Sentinelas conseguem enviar mensagens.\n\n@everywhere function spmd_teste_send_recv()\n    # primeiro encontra a cobra\n    if myid() == 2\n        println(\"$(myid()) achou a cobra\")\n        cobra = 2\n    else\n        cobra = nothing\n    end\n\n    # notifica todos os sentinelas\n    aonde_esta_cobra = bcast(cobra, 2)\n    barrier(;pids=[2,3,4])\n\n    # dependendo do nome, a sentinela toma\n    # uma ação diferente\n    if myid() ≠ 2\n        # outras sentinelas dizem que escutaram\n        mensagem = \"$(myid()) entendeu o recado\"\n        sendto(aonde_esta_cobra, mensagem)\n    elseif myid() == 2\n        # sentinela 2 fica esperando todas\n        # falaram que entenderam\n\n        outras_sentinelas = [3,4]\n        for sentinela = outras_sentinelas\n            mensagem = recvfrom(sentinela)\n            println(mensagem)\n        end\n    end\n    barrier(;pids=[2,3,4])\n\n    nothing\nend\n\nspmd(spmd_teste_send_recv; pids=workers())\nrmprocs();"
  },
  {
    "objectID": "PART_3/18_spmd.html#último-teste",
    "href": "PART_3/18_spmd.html#último-teste",
    "title": "18  SPMD",
    "section": "18.3 Último Teste",
    "text": "18.3 Último Teste\nAgora Daisy tem condições de fazer um código realistico.\nQuando uma cobra é avistada, todos os sentinelas são notificados. Todos os suriciates deveriam ir até a serpente para formar um pequeno exército. Contudo, alguns suricates têm medo, e permanecem em suas posições.\nSe a maioria comparecer ao local, o exército consegue fazer gritos o suficiente para espantar o inimigo. Do contrário, a cobra terá um suricate no seu cardápio.\n\n\n\n\n\nO código final de Daisy levou tudo isso em conta, cada sentinela tem 50% de chance de enfrentar a cobra - do mesmo jeito que seus pais lhe faziam ficar em casa.\n\nusing Distributed\naddprocs(5)\n@everywhere using DistributedArrays\n@everywhere using DistributedArrays.SPMD\n\n@everywhere function spmd_snake_drill()\n    sentinela = myid()\n    if sentinela == 2\n        cobra = 2\n        println(\"Sentinela '$(sentinela)' avistou uma cobra.\")\n    else\n        cobra = nothing\n    end\n\n    # notificar todos os sentinelas\n    aonde_esta_cobra = bcast(cobra, 2)\n    barrier(;pids=[2,3,4,5,6])\n\n\n    if sentinela ≠ 2\n        exercito = nothing\n        println(\"Sentinela '$(sentinela)' escutou o recado...\")\n        if rand() > 0.5\n            println(\" e '$(sentinela)' pode ajudar.\")\n            podeAjudar = true\n            sendto(aonde_esta_cobra, podeAjudar)\n        else\n            println(\" e '$(sentinela)' não pode ajudar.\")\n            podeAjudar = false\n            sendto(aonde_esta_cobra, podeAjudar )\n        end\n    elseif sentinela == 2\n        # todos os membros do exército\n        exercito = [2] # o sentinela 2 vai participar\n\n        outras_sentinelas = [3,4,5,6]\n        for sentinela = outras_sentinelas\n            podeAjudar = recvfrom(sentinela)\n            if podeAjudar\n                push!(exercito, sentinela)\n                println(\"'$(sentinela)' chegou para ajudar.\")\n            end\n        end\n        println(\"O exército $(exercito) irá lutar!\")\n        println(\"-------\")\n    end\n    barrier(;pids=[2,3,4,5,6])\n\n\n    if sentinela == 2\n        qtd_suricates = 5\n        ## Se a maioria dos suricates estiver\n        ## no exército, eles ganham\n        if length(exercito) > qtd_suricates÷2\n            println(\"--> Exército venceu.\")\n            println(\"A cobra foi derrotada.\")\n        else\n            println(\"--> O exército perdeu.\")\n            println(\"A cobra teve sua refeição.\")\n        end\n    end\n    nothing\nend\n\nspmd(spmd_snake_drill; pids=workers())\nrmprocs();"
  }
]