[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Paralelismo com Suricates",
    "section": "",
    "text": "Bem-vindo Suricate\nEste tutorial introduz a Programação Paralela em Julia através de uma narrativa envolvente e misteriosa. A história é tecida com exemplos de código, permitindo que você aprenda enquanto se diverte. É possível entender a narrativa sem se aprofundar no código, mas a parte de programação pode não ser tão clara sem o contexto da história.\nO conteúdo é destinado a programadores iniciantes em programação paralela e/ou aqueles não familiarizados com a sintaxe de Julia ou Python.\nSe você tem experiência com programação paralela em Fortran, C++ ou Matlab, mas é novo no Python, não pule a introdução. Ela foi desenhada para facilitar sua transição.\nPara os experientes em programação que desejam descobrir o paralelismo em Julia, este material é perfeito. No entanto, focaremos na sintaxe básica e nas funcionalidades essenciais, evitando algoritmos paralelos avançados.\nEspero que você não só goste, mas também aprenda algo valioso.\n\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books."
  },
  {
    "objectID": "PART_1/00_intro_story.html",
    "href": "PART_1/00_intro_story.html",
    "title": "A Tempestade",
    "section": "",
    "text": "O deserto é um lugar difícil e implacável, onde apenas as criaturas mais adaptáveis ​​podem sobreviver. Entre as areias movediças e o calor escaldante, uma comunidade movimentada de animais prospera em uma intricada teia de sobrevivência. O suricata, com seus olhos aguçados e movimentos ágeis, é um ator-chave nesta paisagem árida.\nLiderando o clã dos suricatas está Mira, uma matriarca sábia e ágil que resistiu a muitas tempestades em seu tempo. Seu pelo é de um rico tom de caramelo, misturando-se perfeitamente com o terreno arenoso ao seu redor. Os olhos de Mira brilham com inteligência enquanto ela examina o horizonte em busca de qualquer sinal de perigo, sempre vigilante para proteger sua enorme família.\nAo lado de Mira está Rocco, um líder suricata promissor, cheio de energia, coragem, e é o líder militar da colônia. Seu pelo é de uma cor amarelo empoeirado, afinal, ele sempre esta trabalhando em todos os tuneis da colônia. Seus olhos eram arregalados, as vezes transmitia entusiasmo e carisma, as vezes transmitia a mais pura energia de um verdadeiro líder.\nNa colônia, Daisy não tinha nada de especial, seu pelo era de um tom suave de creme igual a de todos. Daisy era apenas uma suricata geek, que aprende tudo na internet com outros suricatas da Índia, mas diferente de suas colegas, tinha o sonha em ingressar no exército e se tornar uma sentilena real para ficar ao lado da admirada matriarca Mira.\n“Eu não consigo fazer nem uma única flexão, qual seria o valor de alguém como ela nas forças armadas?” Ela se pergunta, enquanto sua família diz que ser sentinela urbana já seria uma carreira perfeita. Algum dia, Daisy provará que todos estão errados, só não sabe como ainda.\n\n\n\n\n\nOs suricatos não são as únicas criaturas que habitam o deserto. As águias representam uma ameaça constante, e em particular, duas águias gigantes são os inimigos constantes da colônia. Suas asas se estendem mais do que qualquer suricata já tinha visto, lançando sombras sinistras sobre as areias movediças abaixo. Essas águias são diferentes de todas as outras no deserto, pois elas caçam durante as tempestades de areia, nunca foram vistas em céu limpo, e sua presença é temida por todos que cruzam seu caminho. Ninguém sabe de onde elas vieram, suas origens estão envoltas em um mistério tão profundo quanto o próprio deserto.\nAlguns dizem que apenas uma das águias já causa a tempestade.\n\nTextos como esse, abaixos da divisão horizontal são apenas para explicação e análise de códigos. Podem ou não conter mais detalhes da história, mas seu foco principal é a programação.\n\n\n\n\n\n\nTodos os métodos, funções ou sintaxes apresentadas nessa parte da história serão utilizadas, de uma forma ou outra, nos próximos capitulos.\n\n\n\nÉ altamente recomendável realizar todos os exercícios, mesmo que pareçam simples à primeira vista, pois eles têm o propósito de familiarizá-lo com a sintaxe de Julia.\nAdicionalmente, alguns trechos de código serão acompanhados pelos resultados exibidos abaixo do código-fonte, proporcionando a certeza de que seus resultados estão em conformidade com as expectativas. Por exemplo:\n\n@show \"Eu sou Daisy\"\npeso = 500 # em gramas\n@show peso/1000; # em kg\n\n\"Eu sou Daisy\" = \"Eu sou Daisy\"\npeso / 1000 = 0.5"
  },
  {
    "objectID": "PART_1/01_for_if.html#for",
    "href": "PART_1/01_for_if.html#for",
    "title": "1  Sair de Casa",
    "section": "1.1 for",
    "text": "1.1 for\nDado uma coleção, por exemplo um Array, você pode acessar cada elemento da seguinte forma\n\n\n\n\n\n\nfor\n\n\n\n\n\n\ncoleção = [\"a\", \"b\", \"1\", \"2\"]\nfor item in coleção\n    println(item)\nend\n\na\nb\n1\n2\n\n\n\n\n\n\n\n\n\n\n\nExercício 1.1\n\n\n\n\n\nPreencha os espaços em branco a seguir para que meses_do_ano armazene Strings com todos os meses do ano, e os exiba na tela.\n\nmeses_do_ano = ______________\nfor _____ in meses_do_ano\n    println(_____)\nend\n\n\n\n\n\n\n\n\n\n\nSolução 1.1\n\n\n\n\n\n\nmeses_do_ano = [\"Janeiro\", \"Fevereiro\", \"Março\", \"Abril\", \n\"Maio\", \"Junho\", \"Julho\", \"Agosto\", \"Setembro\", \n\"Outubro\", \"Novembro\", \"Dezembro\"]\nfor mês in meses_do_ano\n    println(mês)\nend\n\n\n\n\nOutra alternativa é ter uma variável com o índice de cada elemento\n\n\n\n\n\n\neachindex\n\n\n\n\n\n\ncoleção = [\"a\", \"b\", \"1\", \"2\"]\nfor idx in eachindex(coleção)\n    valor = coleção[idx]\n    println(\"indice $(idx) tem valor $(valor)\")\nend\n\nindice 1 tem valor a\nindice 2 tem valor b\nindice 3 tem valor 1\nindice 4 tem valor 2\n\n\n\n\n\n\n\n\n\n\n\nExercício 1.2\n\n\n\n\n\nPreencha os espaços em branco no código fornecido para obter a saída desejada.\n\ncoleção = [\"a\", \"b\", \"1\", \"2\"]\nfor idx in eachindex(coleção)\n    valor = coleção[idx]\n    println(\"______ $(______) tem valor $(______)\")\nend\n\nSaída Desejada:\n\níndice 1 tem valor a\níndice 2 tem valor b\níndice 3 tem valor 1\níndice 4 tem valor 2\n\n\n\n\n\n\n\n\n\n\nSolução 1.2\n\n\n\n\n\n\ncoleção = [\"a\", \"b\", \"1\", \"2\"]\nfor idx in eachindex(coleção)\n    valor = coleção[idx]\n    println(\"indice $(idx) tem valor $(valor)\")\nend\n\n\n\n\nContudo, a maneira recomendada para produzir indices e valores ao mesmo tempo é com enumerate\n\n\n\n\n\n\nenumerate\n\n\n\n\n\n\ncoleção = [\"a\", \"b\", \"1\", \"2\"]\nfor (idx, valor) in enumerate(coleção)\n    println(\"indice $(idx) tem valor $(valor)\")\nend"
  },
  {
    "objectID": "PART_1/01_for_if.html#if",
    "href": "PART_1/01_for_if.html#if",
    "title": "1  Sair de Casa",
    "section": "1.2 if",
    "text": "1.2 if\nCondicionais em Julia usam o comando if\n\n\n\n\n\n\nìf\n\n\n\n\n\n\ncondição_1 = true\ncondição_2 = true\nif condição_1 == true\n    println(\"entrou condição 1\")\nelseif condição_2 == true\n    println(\"entrou condição 2\")\nelse\n    println(\"entrou no else\")\nend\n\nentrou condição 1\n\n\n\n\n\nSe a condição_1 já é uma variável booleana (true/false), a comparação pode ser omitidida\n\n\n\n\n\n\nìf simplificado\n\n\n\n\n\n\ncondição_1 = false\ncondição_2 = true\nif condição_1\n    println(\"entrou condição 1\")\nelseif condição_2\n    println(\"entrou condição 2\")\nelse\n    println(\"entrou no else\")\nend\n\nentrou condição 2\n\n\n\n\n\n\n\n\n\n\n\nExercício 1.3\n\n\n\n\n\nSimplifique o código de Daisy sem a comparação explicita da variável permissão\n\nfor dia in dias_da_semana\n    if ______________\n        println(\"Daisy PODE CAÇAR na $(dia)\")\n    else\n        println(\"Daisy FICA EM CASA na $(dia)\")\n    end\nend\n\n\n\n\n\n\n\n\n\n\nSolução 1.3\n\n\n\n\n\n\nfor dia in dias_da_semana\n    if rand() &gt; 0.5\n        println(\"Daisy PODE CAÇAR na $(dia)\")\n    else\n        println(\"Daisy FICA EM CASA na $(dia)\")\n    end\nend"
  },
  {
    "objectID": "PART_1/02_function.html#functions",
    "href": "PART_1/02_function.html#functions",
    "title": "2  Ombros Largos",
    "section": "2.1 Functions",
    "text": "2.1 Functions\nExistem 3 maneiras de criar funções em Julia.\n\n\n\n\n\n\nDeclaração Padrão\n\n\n\n\n\n\nfunction achar_domingos(dias)\n    idx_domingos = Int[]\n    for (idx, dia) in enumerate(dias) \n        if dia == \"Dom\"\n            push!(idx_domingos, idx)\n        end\n    end\n    return idx_domingos\nend\n\n\n\n\n\n\n\n\n\n\nExercício 2.1\n\n\n\n\n\nComplete a função a seguir para que ela retorne a permissão de caça com base em uma probabilidade fornecida como variável chamada probabilidade.\nDica: Primeiro o código verifica se o Input é válido, e probabildiades não podem ser negativas não é verdade?\n\nfunction pode_caçar(probabilidade)\n    if probabilidade &lt; ____ || probabilidade &gt; ______\n        @error \"Probabiidade Inválida\"\n    end\n\n    permissão = ________ &gt; ________\n    if __________\n        return ________\n    end\n    return ________\nend\n\n\n\n\n\n\n\n\n\n\nSolução 2.1\n\n\n\n\n\n\nfunction pode_caçar(probabilidade)\n    if probabilidade &lt; 0 || probabilidade &gt; 1\n        @error \"Probabiidade Inválida\"\n    end\n\n    permissão = rand() &gt; probabilidade\n    if permissão\n        return true\n    end\n    return false\nend\npode_caçar(probabilidade)\n\n\n\n\n\n\n\n\n\n\nDeclaração em Uma Linha\n\n\n\n\n\nA segunda maneira é apenas o nome da função com seus argumentos.\nEsta forma é conveniente para funções simples que têm uma única expressão como corpo.\nNesse exemplo, vemos uma versão equivalente ao apresentado na Declaração Padrão anterior, porém mais compacto.\n\nachar_domingos(dado) = [idx for (idx, dia) in enumerate(dias) if dia == \"Dom\"];\n\n\n\n\n\n\n\n\n\n\nExercício 2.2\n\n\n\n\n\nCrie uma função, de uma linha, e sem inputs, que retorne um array com os dias da semana.\n\n\n\n\n\n\n\n\n\nSolução 2.2\n\n\n\n\n\n\ndias_semana() = [\"Seg\", \"Ter\", \"Qua\", \"Qui\", \"Sex\", \"Sab\", \"Dom\"]\n\n\n\n\n\n\n\n\n\n\nFunção Anônima\n\n\n\n\n\nTerceira maneira é com funções anônimas, isto é, sem nomes, que são indicadas com -&gt;.\nSão úteis quando você precisa passar uma função como argumento para outra função ou quando deseja criar funções temporárias. Esse cenário acontece quando precisamos passar funções como entradas, aqui mostramos a função map - que será explicada na próxima atividade.\n\ndias = [\"Sab\", \"Dom\", \"Seg\"]\nmap(x -&gt; x==\"Dom\", dias)\n\nÉ equivalente a criar uma função temporária\n\ndias = [\"Sab\", \"Dom\", \"Seg\"]\nfunction _temp(x)\n    if x==\"Dom\"\n        return true\n    else\n        return false\n    end\nend\nmap(_temp, dias)"
  },
  {
    "objectID": "PART_1/02_function.html#operação-elemento-a-elemento",
    "href": "PART_1/02_function.html#operação-elemento-a-elemento",
    "title": "2  Ombros Largos",
    "section": "2.2 Operação Elemento-a-Elemento",
    "text": "2.2 Operação Elemento-a-Elemento\nUma aplicação do ponto . antes de qualquer operador significa que o respectivo método será aplicado em todos os elementos do vetor.\nEsse ponto é a função broadcast e você o encontrará constantemente em códigos Julia.\n\n\n\n\n\n\nbroadcast\n\n\n\n\n\nComparações podem ser feitas com o comando == ou isequal\n\nA = [\"a\", \"b\", \"a\", \"c\"]\n@show A .== \"a\";\n@show isequal.(A, \"a\");\n\nA .== \"a\" = Bool[1, 0, 1, 0]\nisequal.(A, \"a\") = Bool[1, 0, 1, 0]\n\n\nEquivalente ao comando\n\n[elemento == \"a\" for elemento in A]\n\n\n\n\n\n\n\n\n\n\nExercício 2.3\n\n\n\n\n\nCrie uma função minha_comparação que retorna true/false de tal forma que ela obtenha a saída desejada\n\n@show minha_comparação(\"Seg\", \"SEG\") # false\n@show minha_comparação.(\"Seg\", [\"SEG\", \"Seg\"]) # Bool[0,1]\n\n\n\n\n\n\n\n\n\n\nSolução 2.3\n\n\n\n\n\n\nfunction minha_comparação(a,b)\n    if a==b\n        return true\n    else\n        return false\n    end\nend\n\n\n\n\n\n\n\n\n\n\nExercício 2.4\n\n\n\n\n\nEscreva uma versão simplificada da função calendario_semanal de forma que elimite as variáveis qtd, agenda, permissão e dias_caçada.\n\n\n\n\n\n\n\n\n\nSolução 2.4\n\n\n\n\n\n\nfunction calendario_semanal_simplificado(dias)    \n    nomes_dias_caçada = String[]\n    for i in eachindex(dias)\n        # probabilidade maior que 50%\n        if rand() &gt; 0.5\n            push!(nomes_dias_caçada, dias[i])\n        end\n    end\n    return nomes_dias_caçada\nend\ndias_da_semana = [\"Seg\", \"Ter\", \"Qua\", \n                  \"Qui\", \"Sex\", \"Sab\", \n                  \"Dom\"]\nRandom.seed!(222)\nprintln( \"Dias que podem sair para caçar: \" )\nprintln( calendario_semanal_simplificado(dias_da_semana) )\n\nDias que podem sair para caçar: \n[\"Qua\", \"Qui\", \"Sab\", \"Dom\"]"
  },
  {
    "objectID": "PART_1/03_map.html#decifrando-a-mensagem",
    "href": "PART_1/03_map.html#decifrando-a-mensagem",
    "title": "3  O Convite",
    "section": "3.1 Decifrando a mensagem",
    "text": "3.1 Decifrando a mensagem\nUtilizamos previamente a função map porém sem muitos detalhes. Agora vamos compreender seu funcionamento, pois essa função será utilizada recorrentemente em no futuro próximo.\n\n\n\n\n\n\nmap\n\n\n\n\n\nA função map aplica uma função, por exemplo, função chamada foo, a cada elemento em uma coleção.\nO retorno dessa função também é uma coleção do mesmo tipo.\n\nfoo(x) = replace(x, \"A\" =&gt; \"B\")\nrespostas = map(foo, coleção)\n\nO código equivalente a esse exemplo seria\n\nfoo(x) = replace(x, \"A\" =&gt; \"B\")\nrespostas = []\nfor item in coleção\n    push!(respostas, foo(item))\nend\n\n\n\n\nPorém, outra maneira de escrever o mesmo código é utilizando uma Função Anônima\n\nmap( x-&gt;replace(x, \"A\" =&gt; \"B\"), coleção)\n\n\n\n\n\n\n\nExercício 3.1\n\n\n\n\n\nO código a seguir obtêm os dias da semana que Daisy pode sair pra caçar com uma função anônima dentro da função filter.\nEscreva um novo código, com for e if, afim de realizar a mesma operação que o filter\n\nfilter(x-&gt;!isequal(x, \"Em Casa\"), [\"Em Casa\", \"Em Casa\", \"Ter\"])\n\n1-element Vector{String}:\n \"Ter\"\n\n\n\n\n\n\n\n\n\n\n\nSolução 3.1\n\n\n\n\n\n\ndias_caçada = String[]\nfor dia in [\"Em Casa\", \"Em Casa\", \"Ter\"]\n    if !isequal(dia, \"Em Casa\") # if dia ≠ \"Em Casa\"\n        push!(dias_caçada, dia)\n    end\nend\n\n\n\n\nNesse exemplo, a função temporária possui apenas 1 comando (replace). Porém, códigos mais interessantes possuem vários comandos\nO que fazer se sua função anônima possui muitas linhas?\nNesse cenário devemos usar a sintaxe do bloco do.\n\n\n\n\n\n\ndo\n\n\n\n\n\nQualquer função cujo primeiro argumento é uma função (como é o caso da função map) pode ser reescrita com a sintaxe do em uma função anônima. Vejamos o exemplo.\n\nmap(coleção) do x\n    replace(x, \"A\" =&gt; \"B\")\nend\n\nVale ressaltar que em códigos com apenas 1 comando, essa sintaxe pode ser muito complicada ou descessária, contudo, para funções com mais instruções, essa sintaxe se torna muito conveniente. Vejamos outro exemplo, primeiro com o uso do bloco do.\n\ncoleção = [\"A\", \"a\", \"B\", \"b\"]\nmap(coleção) do x\n    y = replace(x, \"A\" =&gt; \"B\")\n    z = replace(y, \"a\" =&gt; \"b\")\n    z\nend\n\n4-element Vector{String}:\n \"B\"\n \"b\"\n \"B\"\n \"b\"\n\n\nA versão alternativa, sem bloco do, necessaria criar uma função anônima com a sintaxe -&gt;, além de ser necessária a adição de begin e end\n\nmap( x-&gt; begin \n    y = replace(x, \"A\" =&gt; \"B\"); \n    z = replace(y, \"a\" =&gt; \"b\"); \n    z end, coleção)\n\n\n\n\n\n\n\n\n\n\nExercício 3.2\n\n\n\n\n\nDaisy recebeu um novo castigo. Ela pode caçar todas as Qua e Qui, mas nos outros dias, a suricata ficará em casa.\nEscreva um código que reflita a nova situação de Daisy com o comando map.\nObs: não existe mais chances envolvidas, Daisy só poderá caçar em tais dias.\n\n\n\n\n\n\n\n\n\nSolução 3.2\n\n\n\n\n\n\ndias = [\"Seg\", \"Ter\", \"Qua\", \n        \"Qui\", \"Sex\", \"Sab\", \n        \"Dom\"]\ndias_caçada = map(dias) do dia\n    if dia in [\"Qua\", \"Qui\"]\n        \"pode caçar\"\n    else\n        \"fica em casa\"\n    end\nend"
  },
  {
    "objectID": "PART_1/03_map.html#usando-o-map",
    "href": "PART_1/03_map.html#usando-o-map",
    "title": "3  O Convite",
    "section": "3.2 Usando o map",
    "text": "3.2 Usando o map\nDaisy decidiu usar a função map em seus códigos faz um tempo. Por exemplo, a sua implementação da função calendario_semanal que Shad conhecia, ficou diferente.\n\nfunction calendario_semanal(dias)\n\n    agenda = map(dias) do dia\n        if rand() &gt; 0.5\n            \"sim\"\n        else\n            \"não\"\n        end\n    end\n\n    dias_caçada = findall( agenda .== \"sim\" )\n    nomes_dias_caçada = dias_da_semana[dias_caçada]\n    return nomes_dias_caçada\nend\n\n\n\n\n\n\n\nExercício 3.3\n\n\n\n\n\nAltere a função anônima dentro do map, de tal forma que você possa substituir o comando findall pelo comando filter.\n\n\n\n\n\n\n\n\n\nSolução 3.3\n\n\n\n\n\n\nfunction calendario_semanal(dias)\n    agenda = map(dias) do dia\n        if rand() &gt; 0.5\n            dia\n        else\n            \"não\"\n        end\n    end\n\n    nomes_dias_caçada = filter(x-&gt;!isequal(x, \"não\"), agenda)\n    return nomes_dias_caçada\nend"
  },
  {
    "objectID": "PART_1/03_map.html#o-segredo",
    "href": "PART_1/03_map.html#o-segredo",
    "title": "3  O Convite",
    "section": "3.3 O segredo",
    "text": "3.3 O segredo\nO código de Daisy esta dizendo implicitamente, que ele foi construído com uma Função Anônima, em homenagem ao grupo hacker Anonymous Desert."
  },
  {
    "objectID": "PART_1/04_inplace.html#documentação",
    "href": "PART_1/04_inplace.html#documentação",
    "title": "4  Primeira Tarefa",
    "section": "4.1 Documentação",
    "text": "4.1 Documentação\nQualquer texto que precede um método será considerado uma documentação, ou docstrings\n\n\n\n\n\n\ndocstrings\n\n\n\n\n\n\n\"retorna tipo da matriz de entrada\"\nqual_tipo(x::Matrix) = eltype(x)\n\n\n\n\nPara acessar o texto no REPL digite ?, e em seguida o nome da função.\n\n?qual_tipo\n\n\n\n\n\n\n\nExercício 4.1\n\n\n\n\n\nEscreva a docstring apropriado, baseada na finalidade do código a seguir, e acesse a documentação via REPL\n\n\"__________________________\"\nsalvar(a::String, b) =  write(\"$(a).txt\", b)\n\n\n\n\n\n\n\n\n\n\nSolução 4.1\n\n\n\n\n\n\n\"criar um arquivo `a.txt` e salvar o valor de `b`\"\nsalvar(a::String, b::String) =  write(\"$(a).txt\", b)\n\n\njulia&gt;?salvar\n\n\nhelp&gt;salvar\n\n\n\n\nPara textos mais longos, utiliza-se aspas triplas \"\"\" no começo e no final para delimitar literais de String que podem conter \" e ignorar a indentação inicial. Isso é particularmente útil quando você deseja definir uma String de várias linhas ou uma String que contém aspas.\n\ns = \"\"\"Isto é uma \"string\" que abrange\nvárias linhas e contém \"aspas\".\"\"\"\n\nExiste um padrão para escrita de docstrings disponivel na documentação de Julia."
  },
  {
    "objectID": "PART_1/04_inplace.html#assert",
    "href": "PART_1/04_inplace.html#assert",
    "title": "4  Primeira Tarefa",
    "section": "4.2 @assert",
    "text": "4.2 @assert\n@assert é uma macro usada para verificar se uma determinada condição é verdadeira, se sim, a macro não faz nada. Senão, ela manifesta um erro\n\n\n\n\n\n\n@assert\n\n\n\n\n\n\nfunction teste_valor(x)\n    @assert x &gt; 5\n    return \"OK\"\nend\n@show teste_valor(10)\nbegin\n    try\n        teste_valor(1)\n    catch\n        println(\"Função falhou, e precisou de tratamento.\")\n    end\nend;\n\nteste_valor(10) = \"OK\"\nFunção falhou, e precisou de tratamento.\n\n\n\n\n\n\n\n\n\n\n\nExercício 4.2\n\n\n\n\n\nQual a condição para que a linha abaixo produza um erro\n\n@assert 1 == _____\n\n\n\n\n\n\n\n\n\n\nSolução 4.2\n\n\n\n\n\nQualquer valor que retorne uma comparação false, por exemplo, com um número qualquer diferente de 1, ou usar tipos que não tem comparação válidos (Integer e String por exemplo).\n\n@show @assert 1 == 0 # AssertionError \n@show @assert 1 == \"1\" # AssertionError"
  },
  {
    "objectID": "PART_1/04_inplace.html#in-place",
    "href": "PART_1/04_inplace.html#in-place",
    "title": "4  Primeira Tarefa",
    "section": "4.3 in-place",
    "text": "4.3 in-place\nOperações in-place são aquelas que modificam diretamente os dados de entrada, em vez de criar novos dados. Isso pode ser útil para melhorar a eficiência do código quando se trabalha com grandes conjuntos de dados, pois pode reduzir a quantidade de memória necessária, em especial com Manipulações Matriciais.\nEm Julia, as funções têm a capacidade de modificar qualquer um dos argumentos de entrada. Contudo, existe uma convenção na linguagem, que é uma regra que impede seus códigos de funcionar, mas é amplamente aceita, que estipula que as funções que modificam seus argumentos de entrada devem ser indicadas com um !. Isso serve para alertar os usuários sobre o comportamento potencialmente mutável da função.\n\n\n\n\n\n\n\nfunction letra_minuscula!(entrada, saida)\n    for (idx, texto) in enumerate(entrada)\n        saida[idx] = lowercase(texto)\n    end \n    return nothing\nend\nentrada = [\"SEG\", \"TER\", \"QUAR\"]\nsaida = fill(\"\", size(entrada))\n\nletra_minuscula!(entrada, saida)\ndisplay(saida)\n\n3-element Vector{String}:\n \"seg\"\n \"ter\"\n \"quar\"\n\n\n\n\n\nComo Daisy recebeu a matriz que será atualizada (mes), ela chamou sua função de calendario_suplementos! e não calendario_suplementos.\n\n\n\n\n\n\nImportante\nA notação mais comum de operação in-place é com .=\n\nentrada = [\"SEG\", \"TER\", \"QUAR\"]\nentrada .= \"QUI\"\ndisplay(entrada)\n\n3-element Vector{String}:\n \"QUI\"\n \"QUI\"\n \"QUI\"\n\n\n\n\n\n\n\n\n\n\n\nExercício 4.3\n\n\n\n\n\nSimplifique o código a seguir\n\nA = [1 2; 3 4]\nB = [5 6; 7 8]\nfor i in eachindex(A)\n    A[i] += B[i]\nend\n\n\n\n\n\n\n\n\n\n\nSolução 4.3\n\n\n\n\n\n\nA = [1 2; 3 4]\nB = [5 6; 7 8]\nA .+= B\n\n\n\n\n\n\n\n\n\n\nExercício 4.4\n\n\n\n\n\nNo código a seguir, o . possui 2 significados, os identifique, explique, e reescreva uma função que realize a mesma operação, mas sem nenhum .\n\nentrada = [\"SEG\", \"TER\", \"QUAR\"]\nsaida = fill(\"\", size(entrada))\nsaida .= lowercase.(entrada)\n\n\n\n\n\n\n\n\n\n\nSolução 4.4\n\n\n\n\n\nO primeiro ., em .=, tem o sentido de operação é in-place. Enquanto o lowercase. indica a operação elemento-a-elemento.\nNota que funções que alteram valor de entrada precisam ter ! no nome.\n\nfunction obter_lowercase!(entrada, saida)\n    for (idx, texto) in enumerate(entrada)\n        saida[idx] = lowercase(texto)\n    end\n    return nothing\nend"
  },
  {
    "objectID": "PART_1/04_inplace.html#tipos-genéricos",
    "href": "PART_1/04_inplace.html#tipos-genéricos",
    "title": "4  Primeira Tarefa",
    "section": "4.4 Tipos Genéricos",
    "text": "4.4 Tipos Genéricos\nAs funções one e zero são usadas para obter a representação do número um e do número zero, respectivamente, para um determinado tipo de dados. O parâmetro de entrada em ambas as funções é o tipo desejado, se você não sabe o tipo de uma variável, pode descobri-lo com eltype.\nEssas funções são essenciais para trabalhar corretamente com operações in-place, pois se deseja garantir que a operação respeite os tipos das variáveis que serão alteradas.\n\n\n\n\n\n\none\n\n\n\n\n\n\n@show one(Int64)\n@show one(Float64)\n@show one(Bool)\n@show one(eltype(1.0)); ## equivalent to 'one(Float64)'\n\none(Int64) = 1\none(Float64) = 1.0\n\n\none(Bool) = true\none(eltype(1.0)) = 1.0\n\n\n\n\n\n\n\n\n\n\n\nExercício 4.5\n\n\n\n\n\nIdentifique o erro e a aponte a respectiva solução do código a seguir\n\nmes = zeros(Bool, 4, 7)\nu = eltype(mes)\nT = one(u)\nF = zeros(u)\n\n\n\n\n\n\n\n\n\n\nSolução 4.5\n\n\n\n\n\nExiste um erro de grafia para a criação da variável F. As funções zero e zeros retornam objetos diferentes, mesmo com nomes semelhantes. zero retorna um valor, e zeros retorna um vetor ou matriz.\n\nF = zeros(u) # errada\nF = zero(u) # certo"
  },
  {
    "objectID": "PART_1/05_named_tuples.html#tuplas-nomeadas",
    "href": "PART_1/05_named_tuples.html#tuplas-nomeadas",
    "title": "5  Mantimentos",
    "section": "5.1 Tuplas Nomeadas",
    "text": "5.1 Tuplas Nomeadas\nTupla Nomeada são variáveis que são armazenadas juntas, e você não poderá alterar seus valores depois.\n\n\n\n\n\n\nSintaxe: Named Tuple\n\n\n\n\n\nVocê cria uma tupla usando parênteses, e o respectivo nome da variável. Não se esqueça da vírgula. Mesmo com apenas 1 elemento.\n\na = 1\nb = 2\nc = (variavel_a = a, variavel_b = b)\n@show c.variavel_a, c.variavel_b\n\n# ou apenas 1 elemento usa a virgula\nc = (variavel_a = a, );\n\n(c.variavel_a, c.variavel_b) = (1, 2)\n\n\n\n\n\n\n\n\n\n\n\nExercício 5.1\n\n\n\n\n\nEscreva uma tupla nomeada com o nome, idade e banda preferida de Daisy.\n\ndados_pessoais =  ( ... )\n\n\n\n\n\n\n\n\n\n\nSolução 5.1\n\n\n\n\n\n\ndados_pessoais =  (nome = \"Daisy Zahara\", idade = 3, banda=\"Beyond the Black\")"
  },
  {
    "objectID": "PART_1/05_named_tuples.html#valores-aleatórios",
    "href": "PART_1/05_named_tuples.html#valores-aleatórios",
    "title": "5  Mantimentos",
    "section": "5.2 Valores Aleatórios",
    "text": "5.2 Valores Aleatórios\n\n\n\n\n\n\nSintaxe: rand\n\n\n\n\n\nPor padrão a função rand() gera valores aleatórios entre 0 e 1, mas você pode fornecer uma coleção (como um array de Strings) e a função rand irá sortear valores aleatórios baseados no conteúdo da coleção.\n\nmenu = [\"aranha\", \"besouro\", \"escorpião\", \"gafanhoto\"]\n@show rand(menu);\n\nrand(menu) = \"besouro\"\n\n\nAlém disso, você pode construir vetores ou matrizes\n\ndisplay(rand(menu, 3, 2)) ;\n\n3×2 Matrix{String}:\n \"gafanhoto\"  \"aranha\"\n \"besouro\"    \"gafanhoto\"\n \"besouro\"    \"besouro\"\n\n\n\n\n\n\n\n\n\n\n\nExercício 5.2\n\n\n\n\n\nDaisy ficou triste por perder a competição, e para se acalmar, foi comer em uma região com apenas aranhas e escorpiões. Dado que essa região que possui 2 vezes mais chances de encontrar aranhas do que escorpioões, como isso seria simulado?\n\n\n\n\n\n\n\n\n\nSolução 5.2\n\n\n\n\n\n\nnovo_menu = [\"aranhas\", \"aranhas\", \"escorpiões\"]\nrand(novo_menu, 10)\n\n10-element Vector{String}:\n \"aranhas\"\n \"aranhas\"\n \"aranhas\"\n \"escorpiões\"\n \"escorpiões\"\n \"aranhas\"\n \"aranhas\"\n \"aranhas\"\n \"aranhas\"\n \"aranhas\""
  },
  {
    "objectID": "PART_1/05_named_tuples.html#compreensão-de-listas",
    "href": "PART_1/05_named_tuples.html#compreensão-de-listas",
    "title": "5  Mantimentos",
    "section": "5.3 Compreensão de Listas",
    "text": "5.3 Compreensão de Listas\nÉ uma maneira compacta de criar dados, já presente em Python por exemplo, que assim como a função map pode deixar a legibilidade do código curta e/ou clara.\n\n\n\n\n\n\nSintaxe: List Comprehension vs [] + push!\n\n\n\n\n\nDaisy esta aprendendo as novas regras de segurança, e não é permitido entrar com certos itens dentro da zona militar. Usando uma compressão de lista, vamos filtrar os itens válidos que Daisy levou em sua mochila no seu primeiro dia de trabalho.\n\nitens_mochila = [\"perfume\", \"chocolate\", \"camiseta\", \"livro\", \"chaveiro\", \"tablet\"]\nitens_validos = [\"chocolate\", \"livro\", \"camiseta\" ]\n\nitens_permitidos = [item for item in itens_mochila if item in itens_validos]\n\n3-element Vector{String}:\n \"chocolate\"\n \"camiseta\"\n \"livro\"\n\n\nUma maneira equivalente de escrever o mesmo código é usando Array vazio e com o comando push!, repare que existe um ! no nome, ou seja, ela altera a variável de entrada.\n\nitens_permitidos = []\nfor item in itens_mochila \n    if item in itens_validos\n        push!(itens_permitidos, item)\n    end\nend\n@show itens_permitidos\n\nitens_permitidos = Any[\"chocolate\", \"camiseta\", \"livro\"]\n\n\n3-element Vector{Any}:\n \"chocolate\"\n \"camiseta\"\n \"livro\"\n\n\n\n\n\n\n\n\n\n\n\nExercício 5.3\n\n\n\n\n\nDaisy já esta pensando em como gastar seu primeiro salário, ele irá comprar produtos da Shopee. Contudo, ela tem que pagar uma taxa de 30% ao valor dos itens importados. Primeiro o valor de cada item é convertido para Pula botsuano, e todos itens abaixo de 500 pulas são livres de imposto. Como Daisy esta fazendo compras de produtos da Namibia, a conversão de Dolar namibiano para Pula botsuano é de 0.7322991.\nConverta o código abaixo que utiliza a função mapreduce em uma Lista de Compreensão.\nObs: mapreduce é parecido ao map, porém realiza uma operação extra, por exemplo adição, em todos os itens que são calculados.\n\nvalor_dolar_namibia = [30, 750, 1547]\nfator_conversao = 0.7322991\n\nvalor_liquido = mapreduce(+, valor_dolar_namibia) do item\n    valor_pula = item*fator_conversao\n    if  valor_pula &gt;= 500\n        valor_pula\n    else\n        0.0\n    end\nend\n\nvalor_bruto = 1.3*valor_liquido\n\n2186.71834251\n\n\n\n\n\n\n\n\n\n\n\nSolução 5.3\n\n\n\n\n\n\nvalor_dolar_namibia = [30, 750, 1547]\nfator_conversao = 0.7322991\n\nvalores_convertidos = valor_dolar_namibia.*fator_conversao\nvalor_liquido = sum([ item for item in valores_convertidos if item &gt; 500])\n\nvalor_bruto = 1.3*valor_liquido\n\n2186.71834251"
  },
  {
    "objectID": "PART_2/00_going_travelling.html#mapas",
    "href": "PART_2/00_going_travelling.html#mapas",
    "title": "Parte 2",
    "section": "Mapas",
    "text": "Mapas\nDaisy é um viajante ávido e adora explorar novos lugares. Ela também é apaixonada por cartografia e cria mapas de suas viagens para documentar suas jornadas.\nNo entanto, ela geralmente acha difícil retratar com precisão o terreno e as características geográficas em seus mapas. Para melhorar a qualidade de seus mapas, ela pesquisou várias técnicas e recentemente se interessou por algoritmos de detecção de bordas.\nUsando detecção de bordas, ela espera ser capaz de identificar e destacar com mais precisão os limites de diferentes características do terreno, como montanhas, rios e vales, e tornar seus mapas mais informativos e visualmente atraentes."
  },
  {
    "objectID": "PART_2/00_going_travelling.html#paralelismo",
    "href": "PART_2/00_going_travelling.html#paralelismo",
    "title": "Parte 2",
    "section": "Paralelismo",
    "text": "Paralelismo\nBem-vindo a este capítulo emocionante! Aqui você terá a oportunidade de realizar uma operação incrível - Identificar Bordas em Imagens - e ainda utilizar o poder do paralelismo com diferentes ferramentas. Não se preocupe se ainda não tem uma imagem em mente, você pode escolher a que mais lhe agrada e usá-la como exemplo. Vamos lá!"
  },
  {
    "objectID": "PART_2/06_edge_detection.html",
    "href": "PART_2/06_edge_detection.html",
    "title": "6  Detecção de Bordas",
    "section": "",
    "text": "O objetivo de Daisy é aprimorar seus mapas detectando bordas, e seu algoritmo é muito simples, ela busca por mudanças abruptas na intensidade. Ela fez o desenho abaixo para ilustrar sua ideia, primeiro, ela converte a imagem do mapa em escala de cinza, compara pixels adjacentes, e diz que qualquer pixel acima de um valor limite (threshold) será considerado uma borda.\n\n\n\n\n\nDepois de detectar as bordas, Daisy pinta a imagem original com pontos vermelho para destacá-los. Dessa vez Daisy precisou instalar pacotes em Julia, ela precisou usar o Images.jl para carregar uma image de alta resolução do planeta todo.\n\n\n\n\n\n\nInstalar Pacotes\n\n\n\n\n\nA primeira maneira de instalar pacotes é com o pacote Pkg\n\nimport Pkg\nPkg.add(\"Images\")\n\nO segundo método é pelo terminal (também chamado REPL de Julia). Você deve apertar o ] no teclado. Isso vai alterar a palavra chave julia&gt; para algo do tipo (@v1.9) pkg&gt;. Em seguida, você pode dizer o comando de instalação.\n\n(@v1.9) pkg&gt; add Images\n\nSerá esperado que você instale todos os pacotes futuramente apresentados.\n\n\n\n\n\n\n\n\n\nSintaxe: Canais de Cores\n\n\n\n\n\nPor padrão, o pacote Images.jl vai carregar imagens representadas em RGB(red, green, blue).\nExistem funções (felizmente) com os mesmos nomes que permitem encontrar os respectivos valores para cada pixel.\n\nsua_imagem = load(\".....\")\num_pixel = sua_imagem[3,5]\nr,g,b = red(um_pixel), green(um_pixel), blue(um_pixel)\n\nMas por exemplo, para encontrar todos os vermelhos de uma imagem, você deve usar o operador broadcast .\n\nsua_imagem = load(\".....\")\ncanal_vermelho = red.(sua_imagem)\n\n\n\n\n\nusing Images\nvermelho = RGBA(1.0,0,0.,1)\nthreshold = 0.02\n\nfunction detectar_bordas(imagem, threshold)\n    T = eltype(imagem) # tipo da matriz\n    altura, comprimento = size(imagem)\n    imagem_nova = zeros(T, altura, comprimento)\n\n    for y = 2:comprimento\n        for x = 2:altura\n            atual = imagem[x,y]\n            acima = imagem[x-1,y]\n            esquerda  = imagem[x,y-1]\n\n            if abs(atual-esquerda) ≥ threshold &&\n               abs(atual-acima) ≥ threshold\n                # se é uma borda, anota com '1'\n                imagem_nova[x,y] = one(T)\n            end\n        end\n    end\n    return imagem_nova\nend\n\nfunction pintar_bordas(imagem, mapa_de_bordas, vermelho)\n    imagem_com_bordas = deepcopy(imagem)\n\n    um = one(eltype(mapa_de_bordas))\n    onde_pintar = findall(mapa_de_bordas .== um)\n    imagem_com_bordas[onde_pintar] .= vermelho\n\n    return imagem_com_bordas\nend\n_original = Images.load(pwd()*\"/world.png\");\nimagem = (red.(_original) + green.(_original) + blue.(_original))/3\n\nbordas = detectar_bordas(imagem, threshold)\nimagem_com_bordas = pintar_bordas(_original, bordas, vermelho)\n\nimagem_com_bordas\n\nEsse código foi escrito com loops sem explorar nenhum paralelismo, por isso iremos chamar esse código de versão sequencial nas próximas seções."
  },
  {
    "objectID": "PART_2/07_at_threads.html",
    "href": "PART_2/07_at_threads.html",
    "title": "7  Threads.@threads",
    "section": "",
    "text": "Daisy quer tornar seu algoritmo de detecção de borda mais eficiente usando processamento paralelo com Threads. Sua opção mais simples em Julia é uma macro usada para a execução paralela threads.@Threads. Quando essa macro é usada, as iterações de loop são distribuídas igualmente entre as várias Threads disponíveis.\n\n\n\n\n\n\nNúmero de Threads\n\n\n\n\n\nO número de Threads usados para a execução paralela é determinado pela variável de ambiente JULIA_NUM_THREADS. Você pode verificar quantos threads você tem disponível chamando a função threads.nthreads()\n\nprintln(Threads.nthreads())\n\n\n\n\nPara deixar o código mais limpo, Daisy transformou a operação de detecção de bordas em uma função independente, assim ela pode focar apenas nos loops.\n\n\n\n\n\n\nkernel\n\n\n\nÉ tradição chamar a lógica central do algoritmo como kernel.\n\n\n\n\n\n\n\n\nSintaxe: @inline\n\n\n\n\n\nFazer uma chamada de função pode ser levemente mais demorado do que um programa contendo todos os comandos.\nSe você quer escrever em formato modular, com várias funções, mas o código final produzido pelo compialdor se torne um código extenso, com todas as funções encapsuladas em apenas um código, você pode dizer isso ao compilador com a macro @inline.\n\n\n\n\nfunction bordas_at_threads(imagem, threshold)\n    T = eltype(imagem) # tipo da matriz\n    altura, comprimento = size(imagem)\n    imagem_nova = zeros(T, altura, comprimento)\n\n    Threads.@threads for y = 2:comprimento\n        for x = 2:altura\n            kernel_bordas!(imagem, imagem_nova, T, threshold, x, y)\n        end\n    end\n    return imagem_nova\nend\n\n@inline function kernel_bordas!(imagem, imagem_nova, tipo_matrix, threshold, x, y)\n    atual = imagem[x,y]\n    acima    = imagem[x-1,y]\n    esquerda  = imagem[x,y-1]\n\n    if abs(atual-esquerda) ≥ threshold &&\n        abs(atual-acima) ≥ threshold\n        # se é uma borda, anota com '1'\n        imagem_nova[x,y] = one(tipo_matrix)\n    end\n    return nothing\nend\n\nbordas_paralelo_v1 = bordas_at_threads(imagem, threshold)\n# testar que código sequencial e paralelo produze o mesmo resultado\n@assert all(bordas .≈ bordas_paralelo_v1)\n\nA função all() é usada para verificar se todos os elementos nas duas imagens são (aproximadamente) iguais usando o operador ≈ (\\approx + TAB). Se o teste passar, significa que a implementação paralela produz a mesma saída que a implementação serial."
  },
  {
    "objectID": "PART_2/08_at_spawn.html",
    "href": "PART_2/08_at_spawn.html",
    "title": "8  Threads.@spawn",
    "section": "",
    "text": "Daisy está animada pois percebeu que existem loops encadeados (um for dentro de outro for) que potencialmente podem se beneficiar de mais paralelismo. Depois de algumas pesquisas, ela decidiu usar Threads.@spawn em seu código. Essa macro permite que cada iteração dos loops sejam executados de forma assíncrona.\nQuando @spawn é usado, uma novo Thread é criada enquanto o thread principal continua com sua execução sem esperar que as Threads terminem. Para fazer o programa principal aguardar pelas Thredas, Daisy precisou usar a macro @sync, para sincronizar as Threads.\nA mudança que Daisy precisou fazer em seu código foi pequena, trocando Threads.@threads por Threads.@spawn e @sync.\n\nfunction bordas_at_spawn(imagem, threshold)\n    T = eltype(imagem) # tipo da matriz\n    altura, comprimento = size(imagem)\n    imagem_nova = zeros(T, altura, comprimento)\n\n    @sync Threads.@spawn for y = 2:comprimento\n        for x = 2:altura\n            kernel_bordas!(imagem, imagem_nova, T, threshold, x, y)\n        end\n    end\n    return imagem_nova\nend\n\nbordas_paralelo_v2 = bordas_at_spawn(imagem, threshold)\n@assert all(bordas .≈ bordas_paralelo_v2)\n\nDaisy reparou que seu novo código é mais lento. Na próxima seção você descobrirá o motivo.\n\n\n\n\n\n\nPode conferir o tempo de execução com\n\n@time bordas_at_threads(imagem, threshold);\n@time bordas_at_spawn(imagem, threshold);"
  },
  {
    "objectID": "PART_2/09_spatial_divison.html",
    "href": "PART_2/09_spatial_divison.html",
    "title": "9  Divisão Espacial",
    "section": "",
    "text": "Daisy descobriu que o motivo para seu código com Threads.@spawn estar lento é que ela criou muitas Threads, ou seja, paras criar várias Threads demora algum tempo e o sistema operacional precisa anotar na memória que essa Threads existem. A solução anterior, com Threads.@threads foi mais eficiente, pois ela criou menos Threads, e cada Thread tinha uma carga de trabalho maior.\nDaisy decidiu que precisa de um controle ainda maior de seu código, ela quer ser mais específica e definir exatamente as regiões no qual cada Thread será executada. Ela quer uma divisão como representado abaixo, utilizando uma foto de suas viagens. Cada cor representa uma região da imagem controlada por uma Thread diferente, nesse exemplo, com 4 Threads.\n\n\n\n\n\nSeu primeiro passo é criar uma nova função que tenha mais controle dos loops, permitindo que Daisy diga exatamente qual região será trabalhada. Isso significa criar um outro for para gerenciar as regiões. Para ser simples, ela criou apenas duas regiões, e ao testar o tempo de execução, viu que é melhor que o código com Threads.@spawn.\n\nfunction bordas_duas_regiões(imagem_cinza, threshold)\n    T = eltype(imagem_cinza)\n    altura, comprimento = size(imagem_cinza)\n    nova_imagem = zeros(T, altura, comprimento)\n    duas_regiões = [2:(comprimento÷2),\n                    (comprimento÷2+1):comprimento]\n\n    @sync for região_y in duas_regiões\n        Threads.@spawn for y = região_y\n            for x = 2:altura\n                kernel_bordas!(imagem_cinza, nova_imagem, T, threshold, x, y)\n            end\n        end\n    end\n\n   return nova_imagem\nend\n_teste_ = bordas_duas_regiões(imagem, threshold)\n@assert all(bordas .≈ _teste_)\n\n\n\n\n\n\n\nRepare que Threads.@spawn e @sync precisaram ser colocados em posições diferentes.\n\n\n\nDaisy sabia que seu computador possuia uma CPU com 4 Cores e 8 Threads, mas ela não queria escrever um código para dividir 8 regiões. Após uma busca rápida na internet, Daisy achou a função Iterators.partition que resolve seu problema.\nPor último, Daisy descobre o tamaho de cada partição baseado na quantidade Threads disponiveis, e em seguida descobre os indices de inicio e fim de cada região.\n\nfunction bordas_varias_regiões(imagem, threshold)\n    T = eltype(imagem)\n    altura, comprimento = size(imagem)\n    imagem_nova = zeros(T, altura, comprimento)\n\n    tamanho_região = comprimento ÷ Threads.nthreads()\n    varias_regiões = collect(\n        Base.Iterators.partition(2:comprimento, tamanho_região)\n        )\n\n    @sync for região_y in varias_regiões\n        Threads.@spawn for y = região_y\n            for x = 2:altura\n                kernel_bordas!(imagem, imagem_nova, T, threshold, x, y)\n            end\n        end\n    end\n\n   return imagem_nova\nend\n\nbordas_paralelo_v3 = bordas_varias_regiões(imagem, threshold)\n@assert all(bordas .≈ bordas_paralelo_v3)"
  },
  {
    "objectID": "PART_2/10_threadsx.html",
    "href": "PART_2/10_threadsx.html",
    "title": "10  ThreadsX",
    "section": "",
    "text": "Daisy está ciente de que escrever código paralelo pode ser complicado e deseja garantir que sua implementação esteja correta. Para evitar bugs em potencial, ela buscou por pacote que possam a ajudar e acabou encontrando o pacote ThreadsX.jl, pois ele é muito fácil de usar, basta substituir funções Base, por exemplo, map por Threads.map.\nContudo, a função map executa uma função e retorna várias respostas. Da maneira como Daisy escreveu seu código, não existe nada a ser retornado, afinal, todas as mudanças já estão sendo escritas na matrix nova_imagem. Daisy então optou por usar a função ThreadsX.foreach, que existe justamente para esses cenários.\n\n\n\n\n\n\nSintaxe: foreach\n\n\n\n\n\nSe você gosta da sintaxe do map mas não precisa unir os resultados no final, use a função foreach.\n\nx = [1,2,3]\ny = map(x) do i\n    2*i\nend\n@show y;\n\nz = similar(x)\nforeach(x) do i\n    z[i] = 2*i\nend\n@show z;\n\ny = [2, 4, 6]\nz = [2, 4, 6]\n\n\n\n\n\n\nusing ThreadsX\nfunction bordas_ThreadsX(imagem, threshold)\n      T = eltype(imagem)\n    altura, comprimento = size(imagem)\n    imagem_nova = zeros(T, altura, comprimento)\n\n    tamanho_região = comprimento ÷ Threads.nthreads()\n    varias_regiões = collect( Base.Iterators.partition(2:comprimento, tamanho_região) )\n    ThreadsX.foreach(varias_regiões) do região_y\n        for y = região_y\n            for x = 2:altura\n                kernel_bordas!(imagem, imagem_nova, T, threshold, x, y)\n            end\n        end\n    end\n\n   return imagem_nova\nend\n\nbordas_paralelo_v4 = bordas_ThreadsX(imagem, threshold)\n@assert all(bordas .≈ bordas_paralelo_v4)"
  },
  {
    "objectID": "PART_2/11_parallel_stencil.html",
    "href": "PART_2/11_parallel_stencil.html",
    "title": "11  ParallelStencil",
    "section": "",
    "text": "Daisy teve um desenvolvimento tão incrível, que o lendário hacker, seu mestre Martin, decidiu levar Daisy a outro nível, Martin disse que processamento de imagens tem um grande aliado, Placas de Vídeo, e que Daisy deveria testar Cuda.\nNo entanto, os pais de Daisy não tem tanto dinheiro e se recusaram a comprar uma GPU. Os pais de Daisy acham que ela deveria estar caçando escorpiões, e quando ela ter seu próprio trabalho, ela mesmo poderá comprar sua RTX 4090.\nDaisy não desistiu. Ela procurou em toda parte por soluções, e finalmente se deparou com um pacote mágico chamado ParallelStencil.jl. Este pacote permitiu que ela fizesse seu código funcionar perfeitamente tanto em CPUs, quando em GPU, se disponível no computador.\nDaisy precisou ler a documentação do pacote, e descobriu que precisava modificar seu kernel para que funcionasse em paralelo, pois programação em placas de vídeo não tem loops com for ou while. O mesmo código (mesmo kernel) é executado em todas as regiões da image, e Daisy, a programadora, é responsável por descobrir qual o índice do loop imaginário.\n\n\n\n\n\n\nSe os parâmetros de entrada da função que está sendo executada em paralelo não forem complexos, o ParallelStencil.jl é capaz de identificar o tamanho da imagem e dividir as tarefas automaticamente. Por isso, foi necessário modificar a função novo_kernel para reduzir a quantidade de parâmetros de entrada necessários.\n\n\n\n\nusing ParallelStencil\n\n# Preciso iniciarlizar o pacote com o tipo de variavel padrão\n# que será utilizado, por exemplo, no comando\n# `ParallelStencil.@ones` a seguir\n@init_parallel_stencil(Threads, Float32, 2);\n\n# Se você já tem placa Nvidia configurada, pode usar essa linha\n# @init_parallel_stencil(CUDA, Float32, 2);\n\n@parallel_indices (x,y) function _novo_kernel!(imagem, imagem_nova, threshold)\n    T = eltype(imagem)\n    altura, comprimento = size(imagem)\n\n    if (    x &gt;= 2  && x &lt;= altura &&\n            y &gt;= 2  && y &lt;= comprimento )\n\n        atual = imagem[x,y]\n        acima    = imagem[x-1,y]\n        esquerda  = imagem[x,y-1]\n\n        if abs(atual-esquerda) ≥ threshold &&\n            abs(atual-acima) ≥ threshold\n            imagem_nova[x,y] = one(T)\n        end\n    end\n    return nothing\nend\n\nfunction bordas_ParStencil!(imagem, threshold)\n    imagem_nova = @zeros(size(imagem)...)\n    @parallel _novo_kernel!(imagem, imagem_nova, threshold)\n\n    return imagem_nova\nend\n\n\nbordas_paralelo_v5 = bordas_ParStencil!(imagem, threshold)\n@assert all(bordas .≈ bordas_paralelo_v5)"
  },
  {
    "objectID": "PART_2/12_benchmarks.html",
    "href": "PART_2/12_benchmarks.html",
    "title": "12  Benchmarks",
    "section": "",
    "text": "Depois de tanto trabalho, Daisy quer comparar todos os métodos e descobrir qual foi solução a mais rápida. Martin, seu mestre, disse que para fazer comparações de códigos que executam rápidamente (menos que 1 segundo) é recomendável utilizar um pacote especializado chamado BenchmarkTools.jl.\nA suricata prontamente utilizou o pacote para comparar todas as funções, e ainda calculou o speed up delas, para saber quantas vezes a função paralela é mais rápida que a solução sequencial.\n\n\n\n\n\n\nSpeedup é compara um valor antigo com o valor novo\n\\[\\text{Speedup} = \\frac{\\text{valor antigo}}{\\text{valor novo}}\\]\n\n\n\n\nusing BenchmarkTools\nimg = imagem\nt = threshold\n\ntempo_execução = zeros(6)\n\ntempo_execução[1] = @belapsed detectar_bordas($img, $t);\ntempo_execução[2] = @belapsed bordas_at_threads($img, $t);\ntempo_execução[3] = @belapsed bordas_at_spawn($img, $t);\ntempo_execução[4] = @belapsed bordas_varias_regiões($img, $t);\ntempo_execução[5] = @belapsed bordas_ThreadsX($img, $t);\ntempo_execução[6] = @belapsed bordas_ParStencil($img, $t);\n\n# primeiro item é a solução sequencial\nspeed_up = tempo_execução[1]./tempo_execução\n\n\nusing UnicodePlots\nnomes_funções = [\"Sequencial\",\n                \"@threads\",\n                \"@spawn\",\n                \"Regiões\",\n                \"ThreadsX\",\n                \"ParStencil\"\n            ]\nfig1 = barplot(nomes_funções, tempo_execução,\n    title=\"Tempo de execução [segundos]\")\nfig2 = barplot(nomes_funções, speedUp,\n    title=\"Speed up\")\n\n# savefig(fig1, \"tempo_execução.txt\")\n# savefig(fig2, \"speed_up.txt\")\n\nOs resultados de Daisy foram:\n\n                     Tempo de execução [segundos]\n              ┌                                        ┐\n   Sequencial ┤■■■■■ 0.0557669\n     @threads ┤■■■■■■■■■ 0.111283\n       @spawn ┤■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■ 0.352736\n      Regiões ┤■■■■■■■■■ 0.10945\n     ThreadsX ┤■■■■■■■■■■ 0.118113\n   ParStencil ┤■■■ 0.0325353\n              └                                        ┘\n                               Speed up\n              ┌                                        ┐\n   Sequencial ┤■■■■■■■■■■■■■■■■■■ 1\n     @threads ┤■■■■■■■■■ 0.501127\n       @spawn ┤■■■ 0.158098\n      Regiões ┤■■■■■■■■■ 0.509519\n     ThreadsX ┤■■■■■■■■■ 0.47215\n   ParStencil ┤■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■ 1.71404\n              └                                        ┘\n\nDaisy ficou surpresa que o código paralelo foi, em geral, mais lento que o sequencial, uma vez que ela sempre escutou o contrário. Martin então explica que programação paralela tem um custo inicial que não é pequeno.\nComo a imagem do seu mapa mundial não tinha gigabytes de tamanho, e a complexidade do algoritmo também foi modesta, a sobrecarga de criar e gerenciar as Threads em paralelo demorou mais tempo que executar 2 loops.\nSomente o seu último código, o bordas_ParStencil, foi o mais rápido, porque ele foi inteligente o suficiente para minimzar a distribuição de tarefas, fazendo valer a pena o paralelismo."
  },
  {
    "objectID": "PART_3/00_going_for_work.html#ao-trabalho",
    "href": "PART_3/00_going_for_work.html#ao-trabalho",
    "title": "Parte 3",
    "section": "Ao Trabalho",
    "text": "Ao Trabalho\nDaisy está determinada a guardar dinheiro para suas futuras viagens - e quem sabe uma placa de vídeo. Para tal, ela decidiu trabalhar para sua gangue. Sua idéia foi oferecer serviços de babá para recém-nascidos. Ela adora passar um tempo com crianças e acredita que seria uma ótima maneira de ganhar dinheiro enquanto relaxa sob o sol. Contudo, isso não será o suficiente…."
  },
  {
    "objectID": "PART_3/00_going_for_work.html#processos-distribuídos",
    "href": "PART_3/00_going_for_work.html#processos-distribuídos",
    "title": "Parte 3",
    "section": "Processos Distribuídos",
    "text": "Processos Distribuídos\nEste é o capítulo que trará ferramentas mais ponderosas, e ao mesmo tempo, trará problemas mais complicados, pois os processos paralelos precisam se comunicar. Em Julia o pacote Distributed.jl é a solução para muitos dos problemas que você poderá encontrar."
  },
  {
    "objectID": "PART_3/13_pmap.html",
    "href": "PART_3/13_pmap.html",
    "title": "13  pmap",
    "section": "",
    "text": "Cuidar dos suricates recém-nascidos foi super fácil para Daisy. Ela os deixava sair para brincar ou relaxar sob o sol. Mais tarde, quando eles voltaram, ela anotava quanto tempo cada suricate ficou brincando.\nDiferente dos outros programas que ela escreveu, dessa vez cada suricate esta em um local diferente, então seus códigos precisarão ser executados em computadores diferentes, ou seja, sem ajuda de multithreading. Martin diz a Daisy que Julia permite executar Julia em computadores diferentes nativamente (ou seja, não preicsa de outros programas), mas requer atenção aos detalhes. O recomendável é usar o pacote Distributed.jl, pois oferece as funções úteis para a grande maioria dos problemas.\nPara simplificar seus relatórios, Daisy atribuiu a cada suricate um número, começando com 2 (já que ela é o número 1). Ela só permitiu que os recém-nascidos brincassem em quatro áreas seguras vigiadas por 4 workers.\n\n\n\n\n\nDaisy deseja um código simples, cada worker vai informar quanto tempo cada suricate filhote ficou brincando no sol. A função ideal para fazer isso sem nenhum paralelismo é map, e Daisy encontrou sua versão equivalente em Distributed.jl, é a pmap.\n\n\n\n\n\n\nSintaxe: Distributed\n\n\n\n\n\nEsse pacote é responsável por criar novas instâncias de Julia em máquinas remotas. Ficaremos com o caso mais simples, e usaremos apenas os vários Cores do seu processador para emular outros computadores.\n\nusing Distributed\naddprocs(3) # 'criou'/'conectou' com 3 máquinas\n...\nrmprocs() # 'apaga'/'desliga' todas as máquinas\n\n\n\n\n\n\n\n\n\n\nSempre que você encontrar o comando rmprocs em algum exemplo, isso significa que é necessário encerrar a sessão atual de Julia e iniciar uma nova. Isso garante que não haja confusão com a quantidade de processos ativos, e garante que futuros tutoriais funcionem corretamente.\n\n\n\nPara que Daisy só escreva seu código em uma máquina, e copie ele em todas as outras, foi necessário o comando @everywhere. A primeira tentativa de Daisy gerou esse código, e que já funciona corretamente.\n\nusing Distributed\naddprocs(4) # 4 playgrounds\n\n@everywhere function brincar_no_sol(suricate)\n    # Cada suricate passa um tempo aleatório no sol\n    tempo = round( 2rand(), digits=2) # tempo brincando\n    println(\"suricate '$(suricate)' brincou $(tempo) horas\")\n    return tempo\nend\n\nsuricates = [2,3,4,5,6] # os 'nomes' dos suricate são seus 'ids'\nrelatorio = pmap(suricates) do suricate\n    brincar_no_sol(suricate)\nend;\n\n      From worker 2:    suricate '2' brincou 0.46 horas\n      From worker 3:    suricate '5' brincou 1.07 horas\n      From worker 4:    suricate '3' brincou 0.46 horas\n      From worker 5:    suricate '4' brincou 1.89 horas\n\n\n      From worker 2:    suricate '6' brincou 1.93 horas"
  },
  {
    "objectID": "PART_3/14_at_spawnat.html",
    "href": "PART_3/14_at_spawnat.html",
    "title": "14  @spawnat",
    "section": "",
    "text": "Depois de implementar seu código usando o paralelismo distribuído, Daisy percebeu que cada suricatinho tinha uma preferência, cada um gostava mais de uma certa região, e Daisy queria respeitar essa preferência. Para tornar o código mais legível, cada suricate foi representado como uma Tupla Nomeada.\n\nsuricates = [(nome=2,região=2),\n            (nome=3, região=2),\n            (nome=4, região=3),\n            (nome=5, região=4),\n            (nome=6, região=4)\n            ]\n\nMas como enviar cada suricate para cada região de preferencia? Para conseguir isso, Daisy voltou a documentação do pacote Distributed.jl, e descobriu a macro @spawnat que faz justamente o que ela buscava.\n\n\n\n\n\n\nSintaxe: @spawnat\n\n\n\n\n\nVocê deve especificar qual o id da máquina que irá executar sua função.\n\nresposta = Distributed.@spawnat id_maquina sua_função(....)\n\nCaso não seja importante o id, poderia usar o comando :any\n\nresposta = Distributed.@spawnat :any sua_função(....)\n\n\n\n\nDiferentemente de multithreading, quando ela executou o código, a resposta não foi o que ela desejava, como foi o caso do pmap, agora com o @spawnat a variável de resposta foi do tipo Future, que servia apenas como ‘nota fiscal’/‘ticket’. Era uma variável que garantia que a tarefa foi enviada ao processo, mas não retornava o valor. Para realmente obter os dados, Daisy precisava usar um comando especial, o fetch.\n\nrelatorio = map(suricates) do s\n    @spawnat s.região brincar_no_sol(s.nome)\nend;\n# Para recuperar a resposta de apenas 1 elemento\n# `fetch(relatorio[1])`\n\ndados_relatorio = fetch.(relatorio)"
  },
  {
    "objectID": "PART_3/15_shared_arrays.html#parte_local",
    "href": "PART_3/15_shared_arrays.html#parte_local",
    "title": "15  SharedArrays",
    "section": "15.1 parte_local",
    "text": "15.1 parte_local\nDaisy não trabalhava sozinha, ela era responsável por uma pequena região, de uma grande área, compartilhada com outros suricates. Sua nova chefe, a suricata Jessie, controlava quais regiões cada suricate é autorizado a trabalhar, e cada região eram chamada de parte_local, pois cada suricate só trabalha na sua parte.\nDaisy já tinha fama de programadora, assim foi convocada por Jessie a escrever um código para verificar que cada suricate esta nos seus limites.\nNessa situação, Daisy precisou usar outro pacote, o SharedArrays.jl, pois ela conseguiria representar a área total de excavação como uma variável compartilhada, no qual cada suricate excavador pode ter acesso.\n\n@everywhere using SharedArrays\nterreno = SharedMatrix{Int}((4,16), pids = workers())\n\n@everywhere function ver_parte_local!(terreno)\n    parte_local = localindices(terreno)\n    println(\"suricate '$(myid())' trabalha em '$(parte_local)'\")\n    terreno[parte_local] .= myid()\nend\nfor w in workers()\n    Distributed.@spawnat w ver_parte_local!(terreno)\nend\nterreno\n\n\n\n\n\n\n\nSintaxe: localindices\n\n\n\n\n\nMatrizes em Julia armazenam os valores de forma continua na memória como na figura abaixo. \nlocalindices retornou os indices implicitos de cada valor, e não as linhas e colunas.\n\n\n\n\n\n\n\n\n\nSintaxe: myid\n\n\n\n\n\nTodos os processos podem acessar e editar todos os valores da variável terreno porque SharedArrays gerencia a memória para que você não tenha que escrever um código para isso. Nesse exemplo, cada processo apenas anotou seu id, obtido com a função myid.\n\n\n\nComo a área possuia 16 locais de excavação e 4 trabalhadores, a distribuição de tarefas era direta, com cada suricate foi designado para 4 locais."
  },
  {
    "objectID": "PART_3/15_shared_arrays.html#túneis",
    "href": "PART_3/15_shared_arrays.html#túneis",
    "title": "15  SharedArrays",
    "section": "15.2 Túneis",
    "text": "15.2 Túneis\nAgora que cada suricate conhece seus limites, eles podem começar a escavação dos seus túneis. No entanto os códigos de Daisy tem um requisito muito forte: a representação do túnel em seus códigos não pode ter lacunas entre as camadas, ou seja, cada camada deve ser conectada à anterior.\n\nDaisy chegou numa solução simples, baseada na sua experiência em anotar dias de que poderia sair de casa, ela vai criar uma matriz de zeros representando o terreno, e as áreas escavadas, ela indicou usando 1. Por enquanto Daisy só tem um protótipo, ele funciona apenas para testar que a construção do túnel esta funcionando como deveria no desenho.\n\n\n\n\n\n\nSintaxe: findfirst\n\n\n\n\n\nPara encontrar o 1 na camada superior, Daisy só precisar a posição do único 1 que deverá estar armazenado, para isso Daisy usou a função findfirst\n\n# encontra o primeiro valor '4'\nx = [4,3,4,4,6]\n@show findfirst(x .== 4)\n\ny = [false, false, true, false, true]\n@show findfirst(y);\n\nfindfirst(x .== 4) = 1\nfindfirst(y) = 3\n\n\n\n\n\n\nfunction escavar_tunel!(terreno)\n    linhas, colunas = size(terreno)\n\n    # primeira linha é a linha do solo\n    ponto_partida = rand(1:colunas)\n    terreno[1, ponto_partida] = one(eltype(terreno))\n\n    for i in 2:linhas\n        ultima_posicao = findfirst( terreno[i-1,:] )\n\n        esquerda = ultima_posicao - 1\n        meio = ultima_posicao\n        direita = ultima_posicao + 1\n\n        if esquerda &lt; 1\n            possiveis_posições = [direita, meio]\n        elseif direita &gt; colunas\n            possiveis_posições = [meio, esquerda]\n        else\n            possiveis_posições = [esquerda, meio, direita]\n        end\n\n        local_para_escavar = rand(possiveis_posições)\n        terreno[i, local_para_escavar] = one(eltype(terreno))\n    end\nend\n\nterreno = zeros(Bool, 10, 6)\nescavar_tunel!(terreno)\n\n# Somente para visualização no terminal\nusing SparseArrays\nsparse(terreno)\n\n10×6 SparseMatrixCSC{Bool, Int64} with 10 stored entries:\n 1  ⋅  ⋅  ⋅  ⋅  ⋅\n 1  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  1  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  1  ⋅  ⋅  ⋅\n ⋅  ⋅  1  ⋅  ⋅  ⋅\n ⋅  1  ⋅  ⋅  ⋅  ⋅\n 1  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  1  ⋅  ⋅  ⋅  ⋅\n 1  ⋅  ⋅  ⋅  ⋅  ⋅\n 1  ⋅  ⋅  ⋅  ⋅  ⋅"
  },
  {
    "objectID": "PART_3/15_shared_arrays.html#terreno-rochoso",
    "href": "PART_3/15_shared_arrays.html#terreno-rochoso",
    "title": "15  SharedArrays",
    "section": "15.3 Terreno Rochoso",
    "text": "15.3 Terreno Rochoso\nEm um certo dia, o local da escavação era mais rochoso que o esperado, e ao mesmo tempo, um dos suricates ficou doente e não podia trabalhar, resultando em uma distribuição desigual de tarefas.\nDaisy foi chamada as pressas, seu protótipo precisa funcionar, e ainda levar em conta a zona de trabalho (parte_local) de cada suricate. Daisy sabia que usar os indices implicitos do SharedArrays não seria útil, a solução foi cada suricate informar carregar consigo em um papel qual sua região de trabalho, ou seja, a parte_local será uma variável de entrada.\n\n@everywhere function escavar_tunel!(terreno, parte_local)\n    qtd_camadas = size(terreno, 1)\n\n    # primeira linha é a linha do solo\n    tamanho_região = length(parte_local)\n    ponto_partida = parte_local[rand(1:tamanho_região)]\n    terreno[1, ponto_partida] = one(eltype(terreno))\n\n    for i in 2:qtd_camadas\n        ulitma_camada = terreno[i-1, parte_local]\n        idx_local = findfirst(ulitma_camada)\n        ultima_posicao = parte_local[idx_local]\n\n        esquerda = ultima_posicao - 1\n        meio = ultima_posicao\n        direita = ultima_posicao + 1\n\n        if esquerda &lt; parte_local[1]\n            possiveis_posições = [direita, meio]\n        elseif direita &gt; parte_local[end]\n            possiveis_posições = [meio, esquerda]\n        else\n            possiveis_posições = [esquerda, meio, direita]\n        end\n\n        local_para_escavar = rand(possiveis_posições)\n        terreno[i, local_para_escavar] = one(eltype(terreno))\n    end\n\n   return nothing\nend\n\n\n# suricate `4` ficou doente\n# então suricate `2` precisou compensar\nrochoso = SharedMatrix{Bool}((16,8+3+6), pids = [2,3,5])\nescavadores = [(nome=2, parte_local=1:8),\n               (nome=3, parte_local=9:11),\n               (nome=5, parte_local=12:17)\n              ]\nfor s in escavadores\n    @spawnat s.nome escavar_tunel!(rochoso, s.parte_local)\nend\n\nsparse(rochoso)\nrmprocs()"
  },
  {
    "objectID": "PART_3/16_distributed_arrays.html#novos-índices",
    "href": "PART_3/16_distributed_arrays.html#novos-índices",
    "title": "16  DistributedArray",
    "section": "16.1 Novos índices",
    "text": "16.1 Novos índices\nFuli também tem experiência com programação, e informa Daisy que seus códigos apesar de bem intencionados, nunca funcionariam na linha de produção, pois SharedArrays.jl é uma solução para emular processos distribuidos, mas exige que os dados sejam compartilhados, ou seja, suas matrizes precisam estar no mesmo computador.\nCaso Daisy queira rodar seus códigos em paralelo de verdade, ela precisa usar o pacote DistributedArrays.jl. Esse pacote facilita a distribuição dos indices de cada trabalhador, mas precisa de um pouco de atenção para acessar os dados corretamente.\n\nDaisy ficou confusa, mas Fuli lhe deu alguns exemplos básicos. Fuli explica que é necessário criar variáveis distribuidas, do mesmo jeito que Daisy criou uma matriz preenchida com zeros, usando a função zeros, o pacote DistributedArrays.jl disponibiliza alguns comandos semelhantes, mas com um d adicional, tal como dzeros, dones.\n\nusing Distributed\naddprocs(2)\n\n@everywhere using DistributedArrays\nexemplo = dzeros(Int64, 3, 6)\n\n@everywhere function ver_indices_globais(exemplo)\n\n    Δx, Δy = DistributedArrays.localindices(exemplo)\n    println(\"índices Globais: Δx = $(Δx), Δy = $(Δy)\")\nend\n\nfor w in workers()\n    @spawnat w ver_indices_globais(exemplo)\nend\nsleep(1) # para dar tempo da mensagem aparecer\n\n      From worker 2:    índices Globais: Δx = 1:3, Δy = 1:3\n      From worker 3:    índices Globais: Δx = 1:3, Δy = 4:6\n\n\n\n\n\n\n\n\nSintaxe: distribute\n\n\n\n\n\nCaso você deseje criar uma matriz no localmente, e depois distribui-lá, é só usar o comando disitrubte(matriz)\n\n# encontra o primeiro valor '4'\nA = [1 0 0; 2 0 0; 3 0 0]\ndA = distribute(A)\n\n3×3 DArray{Int64, 2, Matrix{Int64}}:\n 1  0  0\n 2  0  0\n 3  0  0\n\n\n\n\n\nUma vez que Daisy conhece os índices globais, os índices locais são iguais aos comprimento de cada intervalo. Fuli alerta Daisy, para escrever em matrizes distribuidas, só podem ser utilizados indices locais, e além disso, com uma palavra chave especial, localpart, então Daisy deveria ter cuidado, e não confundir o parte_local que ela já havia criado anteriormente - talvez uma mudança de nome de variáveis seriam bem vindas, Daisy precisaria falar com seu mestre.\n\n@everywhere function escrever_indice_local!(exemplo)\n\n    Δx, Δy = DistributedArrays.localindices(exemplo)\n    indice_local_x = 1:length(Δx)\n    indice_local_y = 1:length(Δy)\n\n    for x in indice_local_x, y in indice_local_y\n        localpart(exemplo)[x, y] = myid()\n    end\nend\nexemplo = dzeros(Int64, 3, 6)\nfor w in workers()\n    @spawnat w escrever_indice_local!(exemplo)\nend\ndisplay(exemplo);\nrmprocs();\n\n3×6 DArray{Int64, 2, Matrix{Int64}}:\n 2  2  2  3  3  3\n 2  2  2  3  3  3\n 2  2  2  3  3  3"
  },
  {
    "objectID": "PART_3/16_distributed_arrays.html#novos-tunéis",
    "href": "PART_3/16_distributed_arrays.html#novos-tunéis",
    "title": "16  DistributedArray",
    "section": "16.2 Novos tunéis",
    "text": "16.2 Novos tunéis\nDaisy fez muitos erros, mas finalmente conseguiu, ela adpatou seu código antigo para utilizar o pacote DistributedArrays.jl. Depois de tantos bugs, Daisy chegou a conclusão que é melhor fazer tratamentos de erro, já que quando bugs acontecem em processos remotos, eles não são redirecionados ao processo central, logo, não existem mensagens de erro na tela.\n\n\n\n\n\n\nSintaxe: try\n\n\n\n\n\nUm bloco try-catch funciona como esperado de outras linguagens de programação, sua utilização básica consiste em apenas colocar o seu código dentro do bloco try.\n\ntry\n    sqrt(-1)\ncatch\n    println(\"Não é possível fazer sqrt(-1)\")\n    println(\"Tente sqrt(Complex(-1))\")\nend\n\nNão é possível fazer sqrt(-1)\nTente sqrt(Complex(-1))\n\n\n\n\n\n\nusing Distributed\naddprocs(3)\n@everywhere using DistributedArrays\n\n@everywhere function d_escavar_tunel!(terreno)\n    try\n        Δx, Δy = DistributedArrays.localindices(terreno)\n\n        qtd_camadas = length(Δx)\n        tamanho_região = length(Δy)\n\n        # primeira linha é a linha do solo\n        ponto_partida = rand(1:tamanho_região)\n\n        # '1' == escavar a posição\n        escavar = one(eltype(terreno))\n        localpart(terreno)[1, ponto_partida] = escavar\n\n        for i in 2:qtd_camadas\n            ulitma_camada = localpart(terreno)[i-1, :]\n\n            # garante que o código funcione para outros\n            # tipos de matrizes, além dos tipos `true`/`false`\n            ultima_posicao = findfirst( ulitma_camada .== escavar )\n\n            esquerda = ultima_posicao - 1\n            meio = ultima_posicao\n            direita = ultima_posicao + 1\n\n            if esquerda &lt; 1\n                possiveis_posições = [direita, meio]\n            elseif direita &gt; tamanho_região\n                possiveis_posições = [meio, esquerda]\n            else\n                possiveis_posições = [esquerda, meio, direita]\n            end\n\n            aonde_escavar = rand(possiveis_posições)\n            localpart(terreno)[i, aonde_escavar] = escavar\n        end\n    catch\n        println(\"Aconteceu um Erro.\")\n    end\n\n   return nothing\nend\n\nA construção da matriz distribuída também requer um cuidado adicional, pois é possível controlar quais suricates vão participar da construção do túnel, e em quantas partes cada dimensão da matriz será particionada.\n\n## Preciso passar uma tupla com as dimensões da matriz\ndimensões_terreno = (10, 6)\n\n## Um vetor com os processos que farão o trabalho\nescavadores = workers()\n\n# Cada componente do vetor, corresponde a qtd\n# de particições em cada dimensão. Por exemplo\n# ['1', 2] = eixo 1 não tem divisão\n# [1, '3'] = eixo 2 é divido em 3 partes\ndivisões = [1, 3]\n\n# não tem função que cria matriz booleana,\n# então preciso usar a função `dfill`\nterreno = dfill(false, dimensões_terreno, escavadores, divisões)\n\nfor w in workers()\n    @spawnat w d_escavar_tunel!(terreno)\nend\n\nusing SparseArrays\nsparse(terreno)\n\nrmprocs()"
  },
  {
    "objectID": "PART_3/17_pipeline.html#remotechannel",
    "href": "PART_3/17_pipeline.html#remotechannel",
    "title": "17  pipeline",
    "section": "17.1 RemoteChannel",
    "text": "17.1 RemoteChannel\nA suricata enfrenta um novo desafio de programação, agora a comunicação entre os processos é crucial. Ela procura a ajuda de Martin e descobre que todos os pacotes anteriores que ela utilizou, já possuiam algum nível de comunicação nos bastidores, mas agora ela precisa aprender esses truques por si mesma. Em Julia, a comunicação entre processos é feita com Channel, e para processos em computadores diferentes, com RemoteChannel.\n\n\n\n\n\n\nSintaxe: remotechannels\n\n\n\n\n\nUm RemoteChannel é um canal de comunicação entre processos que funciona com uma fila, logo, a primeira mensagem a ser colocada, é a primeira ser retirada (FIFO). Todos os processos podem escrever dados com pu!, e efetuar leitura com take!.\n\nusing Distributed\naddprocs(3)\n\n# todos os processos podem\n# ler e escrever até 4 mensagens\nRC = RemoteChannel(() -&gt; Channel(4))\n\n# uso o comando `put!`\n## líder\nput!(RC, \"mensagem 1\")\n\n## trabalhadores\n@spawnat 2 put!(RC, \"mensagem 2\")\n@spawnat 3 put!(RC, \"mensagem 3\")\n@spawnat 4 put!(RC, \"mensagem 4\")\n\n\n# ler dados é com o `take!`\n@everywhere function ler_dado(RC)\n    mensagem = take!(RC)\n    println(mensagem)\nend\n\n# cada processo para faz uma leitura\n## líder\nler_dado(RC);\n\n## trabalhadores\n@spawnat 2 ler_dado(RC);\n@spawnat 3 ler_dado(RC);\n@spawnat 4 ler_dado(RC);\n\nrmprocs()\n\nAtenção Se você pede a leitura dos dados, a execução do programa fica travada esperando pelos dados. Então no exemplo, após a leitura das 4 mensagens, se fosse requisitado uma nova leitura, o código ficaria travado indefinitivamente.\n\n(...)\n@spawnat 3 ler_dado(RC);\n@spawnat 4 ler_dado(RC);\n\n# A fila esta vazia, portanto uma nova leitura\n# iria ficar aguardando infinitamente algum dado\nler_dado(RC)\n\n\n\n\nMartin alerta Daisy que suas funções precisam virar serviços, ela precisará criar funções que rodam eternamente, apenas esperando por requisições, só assim, ela pipelines funcionarem. A solução mais simples é criar funções dentro de bloco while true ... end.\n\n\n\n\n\n\nSintaxe: Serviços Remotos\n\n\n\n\n\nVocê vai aproveitar do fato que take! fica aguardando dados por tempo indeterminado, mas não no nó líder (processo 1), mas apenas nos trabalhadores remotos, já que assim não atrapalha a execução do seu programa.\n\nusing Distributed\naddprocs(2)\n\n@everywhere function ler_dado(RC)\n    while true\n        mensagem = take!(RC)\n        sleep(1)\n        println(mensagem)\n    end\n    return nothing\nend\n\n# canal aceita apenas 4 dado por vez\nRC = RemoteChannel(() -&gt; Channel(4))\n\n# apenas o processo '2' ficará\n# travado esperando por dados\n@spawnat 2 ler_dado(RC)\n\nput!(RC, \"mensagem 1\");\nput!(RC, \"mensagem 2\");\n@spawnat 3 put!(RC, \"mensagem 3\");\n@spawnat 3 put!(RC, \"mensagem 4\");\n\nrmprocs()\n\nTask (done) @0x00007f2ee6289cf0\n\n\n\n\n\nDaisy atualizou seu desenho para ser mais técnica, e incluir o que aprendeu."
  },
  {
    "objectID": "PART_3/17_pipeline.html#nova-escavação",
    "href": "PART_3/17_pipeline.html#nova-escavação",
    "title": "17  pipeline",
    "section": "17.2 Nova Escavação",
    "text": "17.2 Nova Escavação\nCriar túneis acontecerá em 2 estágios, logo, Daisy pegou os códigos antigos, e os adaptou para o novo desafio. Dessa vez ela reparou que poderia ser muito mais eficiente. Se no lugar ter uma matriz com 0 e 1, ela poderia ter apenas um vetor contendo a posição exata da escavação (apenas a posição do indice aonde ficaria registrado o valor 1).\nAbaixo, Daisy escreveu seu código para as primeiras etapas.\n\nusing Distributed\naddprocs(3)\n\n@everywhere function etapa_1(qtd_camadas, tamanho_região, RC_entrada, RC_saida)\n    while true\n        ponto_partida = take!(RC_entrada)\n        println(\"[Começou] Primeira Etapa\")\n\n        pontos_escavação = [ponto_partida]\n        escavar!(pontos_escavação, qtd_camadas, tamanho_região)\n\n        put!(RC_saida, pontos_escavação)\n        println(\"[Terminado] Primeira Etapa\")\n    end\nend\n\n@everywhere function etapa_2(qtd_camadas, tamanho_região, RC_entrada, RC_saida)\n    while true\n        # recebe as etapas anteriores\n        pontos_escavação = take!(RC_entrada)\n        println(\"[Começou] Segundo Etapa\")\n\n        escavar!(pontos_escavação, qtd_camadas, tamanho_região)\n\n        put!(RC_saida, pontos_escavação)\n        println(\"[Terminado] Segundo Etapa\")\n    end\nend\n\n@everywhere @inline function escavar!(pontos_escavação, qtd_camadas, tamanho_região)\n\n    for i in 2:qtd_camadas\n        ultima_posicao = pontos_escavação[end]\n\n        esquerda = ultima_posicao - 1\n        meio = ultima_posicao\n        direita = ultima_posicao + 1\n\n        if esquerda &lt; 1\n            possiveis_posições = [direita, meio]\n        elseif direita &gt; tamanho_região\n            possiveis_posições = [meio, esquerda]\n        else\n            possiveis_posições = [esquerda, meio, direita]\n        end\n        aonde_escavar = rand(possiveis_posições)\n        push!(pontos_escavação, aonde_escavar)\n    end\n    return nothing\nend"
  },
  {
    "objectID": "PART_3/17_pipeline.html#mapa-de-profundidade",
    "href": "PART_3/17_pipeline.html#mapa-de-profundidade",
    "title": "17  pipeline",
    "section": "17.3 Mapa de Profundidade",
    "text": "17.3 Mapa de Profundidade\nPara a terceira fase, Fuli precisava de um mapa agradável aos olhos, já que ele iria apresentar os resultados em formato de relatório aos investidores - e suricates investidores também tem medo de ver números brutos.\nBaseada em sua experiência com detecção de bordas, Daisy decidiu criar um mapa pintado de vermelho aonde foi escavado, e quanto mais profundo, mais escuro ficam as cores.\n\n@everywhere using Images\n@everywhere function etapa_3(qtd_camadas, tamanho_região, RC_entrada, RC_saida)\n    while true\n        # recebe o túnel completo\n        pontos_escavação = take!(RC_entrada)\n        println(\"[Começou] Terceira Etapa\")\n\n        # mais profundo == mais escuro\n        alphas = range(1.0, 0.25, length = 2qtd_camadas)\n        mapa = [RGBA(1.0, 1.0, 1.0, 1.0)\n            for i ∈ 1:2qtd_camadas, j ∈ 1:tamanho_região]\n\n        for i in eachindex(pontos_escavação)\n            # mostra a divisão entre etapas\n            # com uma cor diferente\n            if i == qtd_camadas\n                mapa[i, :] .= RGBA(1.0, 1.0, 1.0, 0.7)\n            end\n\n            mapa[i, pontos_escavação[i]] = RGBA(1.0, 0.0, 0.0, alphas[i])\n        end\n\n        put!(RC_saida, mapa)\n        println(\"[Terminado] Terceira Etapa\")\n    end\nend"
  },
  {
    "objectID": "PART_3/17_pipeline.html#fuli",
    "href": "PART_3/17_pipeline.html#fuli",
    "title": "17  pipeline",
    "section": "17.4 Fuli",
    "text": "17.4 Fuli\nDaisy pegou seu último desenho e o traduziu para códigos. Ela precisava de 4 canais remotos. Uma vez criados, ela notificou cada suricate com as dimensões do projeto, para que eles ficassem aguardando instruções.\n\nRC_1 = RemoteChannel(() -&gt; Channel(1))\nRC_2 = RemoteChannel(() -&gt; Channel(1))\nRC_3 = RemoteChannel(() -&gt; Channel(1))\nRC_4 = RemoteChannel(() -&gt; Channel(1))\n\nqtd_camadas, comprimento = 25, 30\n@spawnat 2 etapa_1(qtd_camadas, comprimento, RC_1, RC_2)\n@spawnat 3 etapa_2(qtd_camadas, comprimento, RC_2, RC_3)\n@spawnat 4 etapa_3(qtd_camadas, comprimento, RC_3, RC_4)\n\nCom tudo preparado, Fuli apareceu, e disse que o ponto de partida de escavação seria bem no centro do terreno.\n\npartida_da_escavação = 15\nput!(RC_1, partida_da_escavação)\n\nNo final do dia, Fuli estava de volta, agora ele queria o mapa dos resultados, antes que todos os suricates fossem dispensados para casa.\n\nmapa_tunel = take!(RC_4)\nsave(\"tunnel_map.png\", mapa_tunel)\n\nrmprocs()\n\nAbaixo, segue um exemplo de túnel escavado da parte superior até a inferior, e a linha cinza indica a transição de um suricate para outro."
  },
  {
    "objectID": "PART_3/18_spmd.html#segundo-teste",
    "href": "PART_3/18_spmd.html#segundo-teste",
    "title": "18  Primeiro Teste",
    "section": "18.1 Segundo Teste",
    "text": "18.1 Segundo Teste\nDaisy consegue comunicar a todos a respeito da ameaça, mas como que ela vai saber quem irá ajudar a combate-lá? Para isso, ela precisou dos comandos sendto e recvfrom - ‘enviar para’ e ‘receber de’ em uma tradução livre. Seu novo código é uma modificação do anterior, para ter certeza que todos os Sentinelas conseguem enviar mensagens.\n\n@everywhere function spmd_teste_send_recv()\n    # primeiro encontra a cobra\n    if myid() == 2\n        println(\"$(myid()) achou a cobra\")\n        cobra = 2\n    else\n        cobra = nothing\n    end\n\n    # notifica todos os sentinelas\n    aonde_esta_cobra = bcast(cobra, 2)\n    barrier(;pids=[2,3,4])\n\n    # dependendo do nome, a sentinela toma\n    # uma ação diferente\n    if myid() ≠ 2\n        # outras sentinelas dizem que escutaram\n        mensagem = \"$(myid()) entendeu o recado\"\n        sendto(aonde_esta_cobra, mensagem)\n    elseif myid() == 2\n        # sentinela 2 fica esperando todas\n        # falaram que entenderam\n\n        outras_sentinelas = [3,4]\n        for sentinela = outras_sentinelas\n            mensagem = recvfrom(sentinela)\n            println(mensagem)\n        end\n    end\n    barrier(;pids=[2,3,4])\n\n    nothing\nend\n\nspmd(spmd_teste_send_recv; pids=workers())\nrmprocs();"
  },
  {
    "objectID": "PART_3/18_spmd.html#último-teste",
    "href": "PART_3/18_spmd.html#último-teste",
    "title": "18  Primeiro Teste",
    "section": "18.2 Último Teste",
    "text": "18.2 Último Teste\nAgora Daisy tem condições de fazer um código realistico.\nQuando uma cobra é avistada, todos os sentinelas são notificados. Todos os suriciates deveriam ir até a serpente para formar um pequeno exército. Contudo, alguns suricates têm medo, e permanecem em suas posições.\nSe a maioria comparecer ao local, o exército consegue fazer gritos o suficiente para espantar o inimigo. Do contrário, a cobra terá um suricate no seu cardápio.\n\n\n\n\n\nO código final de Daisy levou tudo isso em conta, cada sentinela tem 50% de chance de enfrentar a cobra - do mesmo jeito que seus pais lhe faziam ficar em casa.\n\nusing Distributed\naddprocs(5)\n@everywhere using DistributedArrays\n@everywhere using DistributedArrays.SPMD\n\n@everywhere function spmd_snake_drill()\n    sentinela = myid()\n    if sentinela == 2\n        cobra = 2\n        println(\"Sentinela '$(sentinela)' avistou uma cobra.\")\n    else\n        cobra = nothing\n    end\n\n    # notificar todos os sentinelas\n    aonde_esta_cobra = bcast(cobra, 2)\n    barrier(;pids=[2,3,4,5,6])\n\n\n    if sentinela ≠ 2\n        exercito = nothing\n        println(\"Sentinela '$(sentinela)' escutou o recado...\")\n        if rand() &gt; 0.5\n            println(\" e '$(sentinela)' pode ajudar.\")\n            podeAjudar = true\n            sendto(aonde_esta_cobra, podeAjudar)\n        else\n            println(\" e '$(sentinela)' não pode ajudar.\")\n            podeAjudar = false\n            sendto(aonde_esta_cobra, podeAjudar )\n        end\n    elseif sentinela == 2\n        # todos os membros do exército\n        exercito = [2] # o sentinela 2 vai participar\n\n        outras_sentinelas = [3,4,5,6]\n        for sentinela = outras_sentinelas\n            podeAjudar = recvfrom(sentinela)\n            if podeAjudar\n                push!(exercito, sentinela)\n                println(\"'$(sentinela)' chegou para ajudar.\")\n            end\n        end\n        println(\"O exército $(exercito) irá lutar!\")\n        println(\"-------\")\n    end\n    barrier(;pids=[2,3,4,5,6])\n\n\n    if sentinela == 2\n        qtd_suricates = 5\n        ## Se a maioria dos suricates estiver\n        ## no exército, eles ganham\n        if length(exercito) &gt; qtd_suricates÷2\n            println(\"--&gt; Exército venceu.\")\n            println(\"A cobra foi derrotada.\")\n        else\n            println(\"--&gt; O exército perdeu.\")\n            println(\"A cobra teve sua refeição.\")\n        end\n    end\n    nothing\nend\n\nspmd(spmd_snake_drill; pids=workers())\nrmprocs();"
  }
]